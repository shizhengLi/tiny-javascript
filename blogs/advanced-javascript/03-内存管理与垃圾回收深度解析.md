# JavaScript 内存管理与垃圾回收深度解析

JavaScript 的内存管理和垃圾回收机制是影响应用性能的关键因素。理解这些机制对于编写高性能、内存安全的 JavaScript 应用至关重要。本文将深入探讨 JavaScript 的内存管理模型和垃圾回收算法。

## JavaScript 内存模型

### 内存区域划分

```javascript
// JavaScript 内存模型示意图
const MemoryModel = {
    // 1. 栈内存 (Stack)
    stack: {
        type: "栈内存",
        characteristics: [
            "后进先出 (LIFO)",
            "自动分配和释放",
            "存储原始类型和引用",
            "大小固定",
            "访问速度快"
        ],
        contents: [
            "原始类型值 (Number, String, Boolean, null, undefined, Symbol)",
            "对象引用地址",
            "函数调用上下文",
            "局部变量"
        ]
    },

    // 2. 堆内存 (Heap)
    heap: {
        type: "堆内存",
        characteristics: [
            "动态分配",
            "大小不固定",
            "手动管理（通过GC）",
            "访问速度相对较慢"
        ],
        contents: [
            "对象实例",
            "数组",
            "函数",
            "闭包"
        ]
    },

    // 3. 代码区 (Code Space)
    codeSpace: {
        type: "代码区",
        contents: [
            "可执行代码",
            "编译后的字节码",
            "优化后的机器码"
        ]
    }
};
```

### 栈内存管理

```javascript
class StackMemorySimulator {
    constructor() {
        this.stack = [];
        this.framePointer = -1;
        this.maxSize = 1000;
    }

    // 压栈操作
    push(value) {
        if (this.stack.length >= this.maxSize) {
            throw new Error("栈溢出: Stack overflow");
        }

        this.stack.push(value);
        this.framePointer++;

        console.log(`压栈: ${value}, 栈大小: ${this.stack.length}`);
        return this;
    }

    // 弹栈操作
    pop() {
        if (this.stack.length === 0) {
            throw new Error("栈为空: Stack is empty");
        }

        const value = this.stack.pop();
        this.framePointer--;

        console.log(`弹栈: ${value}, 栈大小: ${this.stack.length}`);
        return value;
    }

    // 查看栈顶
    peek() {
        if (this.stack.length === 0) {
            return null;
        }
        return this.stack[this.stack.length - 1];
    }

    // 获取栈大小
    size() {
        return this.stack.length;
    }

    // 清空栈
    clear() {
        this.stack = [];
        this.framePointer = -1;
        console.log("栈已清空");
    }

    // 打印栈内容
    printStack() {
        console.log("=== 栈内容 ===");
        this.stack.forEach((item, index) => {
            console.log(`[${index}]: ${item}`);
        });
        console.log("============");
    }
}

// 使用示例
const stack = new StackMemorySimulator();

// 模拟函数调用栈
function simulateFunctionCalls() {
    console.log("模拟函数调用栈...");

    // main 函数
    stack.push("main()");

    // foo 函数调用
    stack.push("foo()");

    // bar 函数调用
    stack.push("bar()");

    // 打印当前栈
    stack.printStack();

    // 函数返回
    console.log("bar() 返回");
    stack.pop();

    console.log("foo() 返回");
    stack.pop();

    console.log("main() 返回");
    stack.pop();

    stack.printStack();
}

simulateFunctionCalls();
```

### 堆内存管理

```javascript
class HeapMemorySimulator {
    constructor() {
        this.heap = new Map();
        this.allocated = new Map();
        this.nextAddress = 0x1000;
        this.totalAllocated = 0;
        this.totalFreed = 0;
    }

    // 分配内存
    allocate(size, type = 'Object') {
        const address = this.nextAddress;
        this.nextAddress += size;

        const block = {
            address: address,
            size: size,
            type: type,
            data: new Array(size).fill(0),
            allocatedAt: Date.now(),
            marked: false
        };

        this.heap.set(address, block);
        this.allocated.set(address, block);
        this.totalAllocated += size;

        console.log(`分配内存: ${type}, 大小: ${size} bytes, 地址: 0x${address.toString(16)}`);
        return address;
    }

    // 释放内存
    free(address) {
        const block = this.heap.get(address);
        if (!block) {
            throw new Error(`无效地址: 0x${address.toString(16)}`);
        }

        this.heap.delete(address);
        this.allocated.delete(address);
        this.totalFreed += block.size;

        console.log(`释放内存: ${block.type}, 大小: ${block.size} bytes, 地址: 0x${address.toString(16)}`);
    }

    // 获取内存使用统计
    getMemoryStats() {
        const allocatedSize = Array.from(this.allocated.values())
            .reduce((sum, block) => sum + block.size, 0);

        return {
            totalAllocated: this.totalAllocated,
            totalFreed: this.totalFreed,
            currentlyAllocated: allocatedSize,
            blockCount: this.allocated.size,
            fragmentationRatio: this.calculateFragmentation()
        };
    }

    // 计算内存碎片率
    calculateFragmentation() {
        if (this.allocated.size === 0) return 0;

        const blocks = Array.from(this.allocated.values())
            .sort((a, b) => a.address - b.address);

        let totalGaps = 0;
        for (let i = 1; i < blocks.length; i++) {
            const gap = blocks[i].address - (blocks[i - 1].address + blocks[i - 1].size);
            totalGaps += gap;
        }

        const totalMemory = this.nextAddress - 0x1000;
        return totalGaps / totalMemory;
    }

    // 打印内存使用情况
    printMemoryUsage() {
        const stats = this.getMemoryStats();
        console.log("=== 内存使用统计 ===");
        console.log(`总分配: ${stats.totalAllocated} bytes`);
        console.log(`总释放: ${stats.totalFreed} bytes`);
        console.log(`当前使用: ${stats.currentlyAllocated} bytes`);
        console.log(`分配块数: ${stats.blockCount}`);
        console.log(`碎片率: ${(stats.fragmentationRatio * 100).toFixed(2)}%`);
        console.log("================");
    }
}

// 使用示例
const heap = new HeapMemorySimulator();

// 模拟内存分配
function simulateMemoryAllocation() {
    console.log("模拟内存分配和释放...");

    // 分配一些对象
    const obj1 = heap.allocate(32, 'Object');
    const obj2 = heap.allocate(64, 'Array');
    const obj3 = heap.allocate(128, 'Function');

    heap.printMemoryUsage();

    // 释放一些内存
    heap.free(obj2);

    heap.printMemoryUsage();

    // 分配更多内存
    const obj4 = heap.allocate(96, 'Object');
    const obj5 = heap.allocate(48, 'String');

    heap.printMemoryUsage();
}

simulateMemoryAllocation();
```

## 垃圾回收机制

### 标记-清除算法

```javascript
class MarkSweepGC {
    constructor(heap) {
        this.heap = heap;
        this.roots = new Set();
        this.markedObjects = new Set();
    }

    // 添加根对象
    addRoot(address) {
        this.roots.add(address);
    }

    // 移除根对象
    removeRoot(address) {
        this.roots.delete(address);
    }

    // 标记阶段
    mark() {
        console.log("开始标记阶段...");
        this.markedObjects.clear();

        // 标记根对象
        for (const rootAddress of this.roots) {
            this.markObject(rootAddress);
        }

        console.log(`标记完成，共标记 ${this.markedObjects.size} 个对象`);
    }

    // 递归标记对象
    markObject(address) {
        const object = this.heap.heap.get(address);
        if (!object || this.markedObjects.has(address)) {
            return;
        }

        // 标记当前对象
        this.markedObjects.add(address);
        object.marked = true;

        // 标记引用的对象（简化实现）
        this.markReferences(object);
    }

    // 标记对象引用
    markReferences(object) {
        // 简化实现：模拟对象引用
        if (object.type === 'Object' && object.references) {
            for (const refAddress of object.references) {
                this.markObject(refAddress);
            }
        }
    }

    // 清除阶段
    sweep() {
        console.log("开始清除阶段...");
        let freedCount = 0;
        let freedSize = 0;

        const toRemove = [];

        // 找出未标记的对象
        for (const [address, object] of this.heap.heap) {
            if (!this.markedObjects.has(address)) {
                toRemove.push(address);
                freedCount++;
                freedSize += object.size;
            }
        }

        // 清除未标记的对象
        for (const address of toRemove) {
            this.heap.free(address);
        }

        console.log(`清除完成，释放 ${freedCount} 个对象，${freedSize} bytes`);
        return { freedCount, freedSize };
    }

    // 执行完整的垃圾回收
    collect() {
        console.log("=== 开始垃圾回收 ===");
        const startTime = performance.now();

        this.mark();
        const result = this.sweep();

        const endTime = performance.now();
        const duration = endTime - startTime;

        console.log(`垃圾回收完成，耗时: ${duration.toFixed(2)}ms`);
        console.log(`释放对象数: ${result.freedCount}`);
        console.log(`释放内存: ${result.freedSize} bytes`);
        console.log("==================");

        return result;
    }

    // 获取回收统计
    getGCStats() {
        return {
            markedObjects: this.markedObjects.size,
            rootObjects: this.roots.size,
            heapObjects: this.heap.heap.size
        };
    }
}

// 使用示例
const gc = new MarkSweepGC(heap);

// 模拟垃圾回收
function simulateGarbageCollection() {
    console.log("模拟垃圾回收过程...");

    // 分配一些对象
    const obj1 = heap.allocate(32, 'Object');
    const obj2 = heap.allocate(64, 'Array');
    const obj3 = heap.allocate(128, 'Function');

    // 添加根对象
    gc.addRoot(obj1);
    gc.addRoot(obj3);

    heap.printMemoryUsage();

    // 执行垃圾回收
    const result = gc.collect();

    heap.printMemoryUsage();

    // 移除根对象
    gc.removeRoot(obj3);

    // 再次执行垃圾回收
    gc.collect();

    heap.printMemoryUsage();
}

simulateGarbageCollection();
```

### 分代垃圾回收

```javascript
class GenerationalGC {
    constructor() {
        this.youngGeneration = {
            eden: new Map(),
            survivor1: new Map(),
            survivor2: new Map(),
            maxSize: 1024 * 1024, // 1MB
            currentSize: 0
        };

        this.oldGeneration = new Map();
        this.roots = new Set();
        this.gcThreshold = 0.8; // 80% 阈值
        this.promotionAge = 2; // 晋升老年代的年龄阈值
    }

    // 在年轻代分配对象
    allocateInYoung(size, type) {
        const address = this.generateAddress();
        const object = {
            address: address,
            size: size,
            type: type,
            age: 0,
            generation: 'eden'
        };

        this.youngGeneration.eden.set(address, object);
        this.youngGeneration.currentSize += size;

        // 检查是否需要触发年轻代GC
        if (this.youngGeneration.currentSize > this.youngGeneration.maxSize * this.gcThreshold) {
            this.collectYoungGeneration();
        }

        return address;
    }

    // 年轻代垃圾回收（复制算法）
    collectYoungGeneration() {
        console.log("执行年轻代垃圾回收...");

        const startTime = performance.now();

        // 标记存活对象
        const liveObjects = this.markLiveObjects();

        // 复制存活对象到survivor区
        this.copyToSurvivor(liveObjects);

        // 清空eden区
        this.youngGeneration.eden.clear();
        this.youngGeneration.currentSize = 0;

        // 交换survivor区
        const temp = this.youngGeneration.survivor1;
        this.youngGeneration.survivor1 = this.youngGeneration.survivor2;
        this.youngGeneration.survivor2 = temp;

        // 检查是否需要晋升到老年代
        this.checkPromotion();

        const endTime = performance.now();
        console.log(`年轻代GC完成，耗时: ${(endTime - startTime).toFixed(2)}ms`);
    }

    // 标记存活对象
    markLiveObjects() {
        const liveObjects = new Set();

        // 标记根对象
        for (const rootAddress of this.roots) {
            this.markObject(rootAddress, liveObjects);
        }

        return liveObjects;
    }

    // 递归标记对象
    markObject(address, liveObjects) {
        // 在eden区查找
        if (this.youngGeneration.eden.has(address)) {
            liveObjects.add(address);
            return;
        }

        // 在survivor1区查找
        if (this.youngGeneration.survivor1.has(address)) {
            liveObjects.add(address);
            return;
        }

        // 在老年代查找
        if (this.oldGeneration.has(address)) {
            liveObjects.add(address);
            return;
        }
    }

    // 复制到survivor区
    copyToSurvivor(liveObjects) {
        for (const address of liveObjects) {
            // 检查对象是否在eden区
            if (this.youngGeneration.eden.has(address)) {
                const object = this.youngGeneration.eden.get(address);
                object.age++;

                // 复制到survivor1区
                this.youngGeneration.survivor1.set(address, object);
            }
        }
    }

    // 检查晋升条件
    checkPromotion() {
        const toPromote = [];

        // 检查survivor1区的对象
        for (const [address, object] of this.youngGeneration.survivor1) {
            if (object.age >= this.promotionAge) {
                toPromote.push(address);
            }
        }

        // 晋升到老年代
        for (const address of toPromote) {
            const object = this.youngGeneration.survivor1.get(address);
            object.generation = 'old';
            this.oldGeneration.set(address, object);
            this.youngGeneration.survivor1.delete(address);
        }

        if (toPromote.length > 0) {
            console.log(`晋升 ${toPromote.length} 个对象到老年代`);
        }
    }

    // 老年代垃圾回收（标记-清除-整理）
    collectOldGeneration() {
        console.log("执行老年代垃圾回收...");

        const startTime = performance.now();

        // 标记阶段
        this.markOldGeneration();

        // 清除阶段
        const result = this.sweepOldGeneration();

        // 整理阶段
        this.compactOldGeneration();

        const endTime = performance.now();
        console.log(`老年代GC完成，耗时: ${(endTime - startTime).toFixed(2)}ms`);
        console.log(`释放 ${result.freedCount} 个对象，${result.freedSize} bytes`);

        return result;
    }

    // 标记老年代对象
    markOldGeneration() {
        const marked = new Set();

        for (const rootAddress of this.roots) {
            this.markOldObject(rootAddress, marked);
        }

        // 更新老年代对象的标记状态
        for (const [address, object] of this.oldGeneration) {
            object.marked = marked.has(address);
        }
    }

    // 标记老年代对象（递归）
    markOldObject(address, marked) {
        if (marked.has(address)) return;
        if (!this.oldGeneration.has(address)) return;

        marked.add(address);

        // 标记引用的对象
        const object = this.oldGeneration.get(address);
        if (object.references) {
            for (const refAddress of object.references) {
                this.markOldObject(refAddress, marked);
            }
        }
    }

    // 清除老年代对象
    sweepOldGeneration() {
        let freedCount = 0;
        let freedSize = 0;
        const toRemove = [];

        for (const [address, object] of this.oldGeneration) {
            if (!object.marked) {
                toRemove.push(address);
                freedCount++;
                freedSize += object.size;
            }
        }

        for (const address of toRemove) {
            this.oldGeneration.delete(address);
        }

        return { freedCount, freedSize };
    }

    // 整理老年代内存
    compactOldGeneration() {
        // 简化的内存整理实现
        const objects = Array.from(this.oldGeneration.values())
            .sort((a, b) => a.address - b.address);

        // 重新分配地址以消除碎片
        let currentAddress = 0x2000;
        for (const object of objects) {
            object.address = currentAddress;
            currentAddress += object.size;
        }
    }

    // 生成地址
    generateAddress() {
        return Date.now() + Math.floor(Math.random() * 1000);
    }

    // 获取GC统计
    getGCStats() {
        return {
            youngGeneration: {
                eden: this.youngGeneration.eden.size,
                survivor1: this.youngGeneration.survivor1.size,
                survivor2: this.youngGeneration.survivor2.size,
                currentSize: this.youngGeneration.currentSize,
                maxSize: this.youngGeneration.maxSize
            },
            oldGeneration: this.oldGeneration.size,
            roots: this.roots.size
        };
    }
}

// 使用示例
const generationalGC = new GenerationalGC();

// 模拟分代垃圾回收
function simulateGenerationalGC() {
    console.log("模拟分代垃圾回收...");

    // 分配一些对象
    for (let i = 0; i < 100; i++) {
        generationalGC.allocateInYoung(64, `Object_${i}`);
    }

    console.log("初始状态:");
    console.log(generationalGC.getGCStats());

    // 添加一些根对象
    const root1 = generationalGC.allocateInYoung(128, 'RootObject1');
    const root2 = generationalGC.allocateInYoung(256, 'RootObject2');
    generationalGC.roots.add(root1);
    generationalGC.roots.add(root2);

    // 触发年轻代GC
    generationalGC.collectYoungGeneration();

    console.log("年轻代GC后:");
    console.log(generationalGC.getGCStats());

    // 继续分配对象
    for (let i = 0; i < 100; i++) {
        generationalGC.allocateInYoung(64, `Object_${i + 100}`);
    }

    // 再次触发年轻代GC
    generationalGC.collectYoungGeneration();

    console.log("第二次年轻代GC后:");
    console.log(generationalGC.getGCStats());
}

simulateGenerationalGC();
```

## 内存泄漏检测与防护

### 内存泄漏检测工具

```javascript
class MemoryLeakDetector {
    constructor() {
        this.objectTraces = new Map();
        this.allocationStacks = new Map();
        this.referenceGraph = new Map();
        this.leakCandidates = new Set();
        this.thresholds = {
            maxLifetime: 30000, // 30秒
            maxReferences: 1000,
            maxSize: 1024 * 1024 // 1MB
        };
    }

    // 跟踪对象分配
    trackAllocation(object, stack, size = 0) {
        const id = this.getObjectId(object);
        const trace = {
            id: id,
            object: object,
            size: size,
            allocatedAt: Date.now(),
            stack: stack,
            references: new Set(),
            referencedBy: new Set(),
            type: this.getObjectType(object)
        };

        this.objectTraces.set(id, trace);
        this.allocationStacks.set(id, stack);

        console.log(`跟踪对象分配: ${trace.type} (ID: ${id})`);
        return id;
    }

    // 跟踪引用关系
    trackReference(fromId, toId) {
        if (this.objectTraces.has(fromId) && this.objectTraces.has(toId)) {
            this.objectTraces.get(fromId).references.add(toId);
            this.objectTraces.get(toId).referencedBy.add(fromId);
        }
    }

    // 检测内存泄漏
    detectLeaks() {
        console.log("开始内存泄漏检测...");
        this.leakCandidates.clear();

        const now = Date.now();

        for (const [id, trace] of this.objectTraces) {
            const lifetime = now - trace.allocatedAt;
            const referenceCount = trace.referencedBy.size;

            // 检查泄漏候选者
            if (lifetime > this.thresholds.maxLifetime &&
                referenceCount === 0 &&
                !this.isRootObject(id)) {
                this.leakCandidates.add(id);
            }
        }

        this.reportLeaks();
    }

    // 检查是否为根对象
    isRootObject(id) {
        const trace = this.objectTraces.get(id);
        if (!trace) return false;

        // 简化实现：检查对象类型
        return trace.type === 'Window' ||
               trace.type === 'Document' ||
               trace.type === 'Global';
    }

    // 报告泄漏
    reportLeaks() {
        console.log("=== 内存泄漏报告 ===");
        console.log(`发现 ${this.leakCandidates.size} 个潜在泄漏对象`);

        for (const id of this.leakCandidates) {
            const trace = this.objectTraces.get(id);
            const lifetime = Date.now() - trace.allocatedAt;

            console.log(`\n泄漏对象 ${id}:`);
            console.log(`  类型: ${trace.type}`);
            console.log(`  大小: ${trace.size} bytes`);
            console.log(`  生存时间: ${lifetime}ms`);
            console.log(`  分配栈:`);
            trace.stack.forEach((frame, index) => {
                console.log(`    ${index}: ${frame}`);
            });
        }

        console.log("=================");
    }

    // 生成对象ID
    getObjectId(object) {
        return `${object.constructor.name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    // 获取对象类型
    getObjectType(object) {
        return object.constructor.name;
    }

    // 获取内存使用统计
    getMemoryStats() {
        const totalSize = Array.from(this.objectTraces.values())
            .reduce((sum, trace) => sum + trace.size, 0);

        const typeStats = new Map();
        for (const trace of this.objectTraces.values()) {
            const type = trace.type;
            if (!typeStats.has(type)) {
                typeStats.set(type, { count: 0, size: 0 });
            }
            typeStats.get(type).count++;
            typeStats.get(type).size += trace.size;
        }

        return {
            totalObjects: this.objectTraces.size,
            totalSize: totalSize,
            leakCandidates: this.leakCandidates.size,
            typeDistribution: Array.from(typeStats.entries())
                .map(([type, stats]) => ({ type, ...stats }))
        };
    }

    // 可视化引用图
    generateReferenceGraph() {
        const nodes = [];
        const edges = [];

        for (const [id, trace] of this.objectTraces) {
            nodes.push({
                id: id,
                label: `${trace.type} (${trace.size}b)`,
                color: this.leakCandidates.has(id) ? 'red' : 'blue'
            });

            for (const refId of trace.references) {
                edges.push({
                    from: id,
                    to: refId
                });
            }
        }

        return { nodes, edges };
    }
}

// 使用示例
const leakDetector = new MemoryLeakDetector();

// 模拟内存泄漏检测
function simulateMemoryLeakDetection() {
    console.log("模拟内存泄漏检测...");

    // 创建一些对象
    const objects = [];

    for (let i = 0; i < 10; i++) {
        const obj = { data: `object_${i}`, size: 64 * (i + 1) };
        const stack = [`function_${i}`, `main`];
        const id = leakDetector.trackAllocation(obj, stack, obj.size);
        objects.push({ obj, id });
    }

    // 建立一些引用关系
    for (let i = 0; i < objects.length - 1; i++) {
        leakDetector.trackReference(objects[i].id, objects[i + 1].id);
    }

    // 等待一段时间
    setTimeout(() => {
        // 移除一些引用（模拟内存泄漏）
        objects.slice(0, 5).forEach(item => {
            leakDetector.objectTraces.get(item.id).referencedBy.clear();
        });

        // 检测泄漏
        leakDetector.detectLeaks();

        // 显示统计
        console.log("内存统计:");
        console.log(leakDetector.getMemoryStats());
    }, 1000);
}

simulateMemoryLeakDetection();
```

### 内存优化策略

```javascript
class MemoryOptimizer {
    constructor() {
        this.optimizations = new Map();
        this.savings = 0;
    }

    // 对象池优化
    createObjectPool(constructor, initialSize = 10) {
        const pool = {
            objects: [],
            constructor: constructor,
            maxSize: initialSize * 2,

            acquire: function() {
                if (this.objects.length > 0) {
                    return this.objects.pop();
                } else {
                    return new this.constructor();
                }
            },

            release: function(obj) {
                if (this.objects.length < this.maxSize) {
                    // 重置对象状态
                    this.resetObject(obj);
                    this.objects.push(obj);
                }
            },

            resetObject: function(obj) {
                // 根据对象类型重置状态
                if (typeof obj.reset === 'function') {
                    obj.reset();
                } else {
                    for (const key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            delete obj[key];
                        }
                    }
                }
            },

            clear: function() {
                this.objects = [];
            }
        };

        // 预分配对象
        for (let i = 0; i < initialSize; i++) {
            pool.objects.push(new constructor());
        }

        return pool;
    }

    // 弱引用缓存
    createWeakCache() {
        const cache = new Map();
        const weakRefs = new Map();

        return {
            get: function(key) {
                const weakRef = weakRefs.get(key);
                if (weakRef) {
                    const value = weakRef.deref();
                    if (value !== undefined) {
                        return value;
                    } else {
                        weakRefs.delete(key);
                    }
                }
                return null;
            },

            set: function(key, value) {
                if (typeof WeakRef !== 'undefined') {
                    weakRefs.set(key, new WeakRef(value));
                } else {
                    // 降级到强引用
                    cache.set(key, value);
                }
            },

            clear: function() {
                weakRefs.clear();
                cache.clear();
            },

            size: function() {
                return weakRefs.size + cache.size;
            }
        };
    }

    // 内存映射优化
    createMemoryMappedArray(size) {
        const buffer = new ArrayBuffer(size);
        const view = new DataView(buffer);
        let offset = 0;

        return {
            writeInt8: function(value) {
                view.setInt8(offset, value);
                offset += 1;
                return this;
            },

            writeInt16: function(value) {
                view.setInt16(offset, value, true);
                offset += 2;
                return this;
            },

            writeInt32: function(value) {
                view.setInt32(offset, value, true);
                offset += 4;
                return this;
            },

            writeFloat64: function(value) {
                view.setFloat64(offset, value, true);
                offset += 8;
                return this;
            },

            readInt8: function() {
                const value = view.getInt8(offset);
                offset += 1;
                return value;
            },

            readInt16: function() {
                const value = view.getInt16(offset, true);
                offset += 2;
                return value;
            },

            readInt32: function() {
                const value = view.getInt32(offset, true);
                offset += 4;
                return value;
            },

            readFloat64: function() {
                const value = view.getFloat64(offset, true);
                offset += 8;
                return value;
            },

            reset: function() {
                offset = 0;
            },

            getBuffer: function() {
                return buffer;
            }
        };
    }

    // 字符串驻留优化
    createStringIntern() {
        const stringPool = new Map();

        return {
            intern: function(str) {
                if (stringPool.has(str)) {
                    return stringPool.get(str);
                } else {
                    stringPool.set(str, str);
                    return str;
                }
            },

            getPoolSize: function() {
                return stringPool.size;
            },

            clear: function() {
                stringPool.clear();
            }
        };
    }

    // 延迟加载优化
    createLazyLoader(factory) {
        let loaded = false;
        let value = null;

        return {
            get: function() {
                if (!loaded) {
                    value = factory();
                    loaded = true;
                }
                return value;
            },

            isLoaded: function() {
                return loaded;
            },

            reset: function() {
                loaded = false;
                value = null;
            }
        };
    }

    // 内存使用监控
    createMemoryMonitor() {
        const snapshots = [];

        return {
            takeSnapshot: function() {
                const snapshot = {
                    timestamp: Date.now(),
                    memory: performance.memory ? {
                        used: performance.memory.usedJSHeapSize,
                        total: performance.memory.totalJSHeapSize,
                        limit: performance.memory.jsHeapSizeLimit
                    } : null,
                    objects: this.countObjects()
                };

                snapshots.push(snapshot);
                return snapshot;
            },

            getSnapshots: function() {
                return snapshots;
            },

            compareSnapshots: function(before, after) {
                if (!before.memory || !after.memory) {
                    return null;
                }

                return {
                    memoryGrowth: after.memory.used - before.memory.used,
                    objectGrowth: after.objects - before.objects,
                    timeElapsed: after.timestamp - before.timestamp
                };
            },

            countObjects: function() {
                // 简化的对象计数
                let count = 0;
                for (let key in window) {
                    if (window[key] && typeof window[key] === 'object') {
                        count++;
                    }
                }
                return count;
            }
        };
    }

    // 应用优化策略
    applyOptimizations() {
        console.log("应用内存优化策略...");

        // 1. 对象池优化
        const vectorPool = this.createObjectPool(function() {
            return { x: 0, y: 0, z: 0 };
        }, 50);

        this.optimizations.set('vectorPool', {
            type: 'ObjectPool',
            pool: vectorPool,
            description: '3D向量对象池'
        });

        // 2. 弱引用缓存
        const weakCache = this.createWeakCache();
        this.optimizations.set('weakCache', {
            type: 'WeakCache',
            cache: weakCache,
            description: '弱引用缓存'
        });

        // 3. 字符串驻留
        const stringIntern = this.createStringIntern();
        this.optimizations.set('stringIntern', {
            type: 'StringIntern',
            intern: stringIntern,
            description: '字符串驻留优化'
        });

        // 4. 内存监控
        const monitor = this.createMemoryMonitor();
        this.optimizations.set('memoryMonitor', {
            type: 'MemoryMonitor',
            monitor: monitor,
            description: '内存使用监控'
        });

        console.log(`已应用 ${this.optimizations.size} 种优化策略`);
    }

    // 获取优化统计
    getOptimizationStats() {
        const stats = {
            totalOptimizations: this.optimizations.size,
            estimatedSavings: this.savings,
            details: []
        };

        for (const [name, optimization] of this.optimizations) {
            stats.details.push({
                name: name,
                type: optimization.type,
                description: optimization.description
            });
        }

        return stats;
    }
}

// 使用示例
const optimizer = new MemoryOptimizer();
optimizer.applyOptimizations();

console.log("优化统计:");
console.log(optimizer.getOptimizationStats());

// 测试对象池
const vectorPool = optimizer.optimizations.get('vectorPool').pool;
const v1 = vectorPool.acquire();
console.log("获取向量:", v1);

v1.x = 10;
v1.y = 20;
v1.z = 30;

vectorPool.release(v1);
console.log("释放向量回池");

const v2 = vectorPool.acquire();
console.log("重用向量:", v2);
```

## 总结

JavaScript 内存管理与垃圾回收是构建高性能应用的关键技术：

1. **内存模型**：栈内存和堆内存的不同管理方式
2. **垃圾回收算法**：标记-清除、分代回收等核心算法
3. **内存泄漏检测**：识别和预防内存泄漏的工具和方法
4. **优化策略**：对象池、弱引用、字符串驻留等优化技术
5. **性能监控**：实时监控内存使用情况

理解这些机制可以帮助我们编写更加高效、稳定的 JavaScript 应用程序。通过合理的内存管理和优化策略，我们可以显著提升应用的性能和用户体验。

下一篇博客将探讨 JavaScript 的并发编程与 Web Workers 技术。