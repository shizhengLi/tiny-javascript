# JavaScript 性能优化与调试技巧深度解析

性能优化和调试是 JavaScript 开发中的核心技能。本文将深入探讨各种性能优化策略、调试技巧和性能分析工具，帮助你构建高性能、稳定可靠的 JavaScript 应用程序。

## 性能分析基础

### 性能指标体系

```javascript
// 性能指标管理系统
class PerformanceMetrics {
    constructor() {
        this.metrics = new Map();
        this.benchmarks = new Map();
        this.alerts = [];
        this.thresholds = {
            // 响应时间阈值（毫秒）
            firstContentfulPaint: 2000,
            largestContentfulPaint: 2500,
            firstInputDelay: 100,
            cumulativeLayoutShift: 0.1,
            timeToInteractive: 3800,

            // 内存使用阈值（字节）
            memoryLeakThreshold: 1024 * 1024 * 50, // 50MB
            memoryFragmentation: 0.3, // 30%

            // CPU 使用阈值（百分比）
            cpuUsageThreshold: 80,

            // 网络请求阈值
            requestTimeout: 5000,
            responseTimeThreshold: 2000,
            requestFailureRate: 0.05 // 5%
        };
    }

    // 记录性能指标
    recordMetric(name, value, unit = 'ms') {
        const metric = {
            name: name,
            value: value,
            unit: unit,
            timestamp: Date.now(),
            tags: {}
        };

        if (!this.metrics.has(name)) {
            this.metrics.set(name, []);
        }

        this.metrics.get(name).push(metric);

        // 检查阈值
        this.checkThreshold(name, value);

        return metric;
    }

    // 检查性能阈值
    checkThreshold(name, value) {
        const threshold = this.thresholds[name];
        if (threshold === undefined) return;

        let isAlert = false;

        if (name.includes('memory') || name.includes('heap')) {
            isAlert = value > threshold;
        } else if (name.includes('time') || name.includes('delay')) {
            isAlert = value > threshold;
        } else if (name.includes('shift')) {
            isAlert = value > threshold;
        } else if (name.includes('rate') || name.includes('usage')) {
            isAlert = value > threshold;
        }

        if (isAlert) {
            this.alerts.push({
                metric: name,
                value: value,
                threshold: threshold,
                timestamp: Date.now(),
                severity: this.calculateSeverity(name, value, threshold)
            });
        }
    }

    // 计算警报严重程度
    calculateSeverity(name, value, threshold) {
        const ratio = value / threshold;
        if (ratio > 2) return 'critical';
        if (ratio > 1.5) return 'high';
        if (ratio > 1.2) return 'medium';
        return 'low';
    }

    // 性能基准测试
    benchmark(name, fn, iterations = 1000) {
        const results = [];
        const memoryBefore = this.getMemoryUsage();

        for (let i = 0; i < iterations; i++) {
            const start = performance.now();
            fn();
            const end = performance.now();
            results.push(end - start);
        }

        const memoryAfter = this.getMemoryUsage();

        const stats = {
            name: name,
            iterations: iterations,
            minTime: Math.min(...results),
            maxTime: Math.max(...results),
            avgTime: results.reduce((a, b) => a + b, 0) / results.length,
            medianTime: this.median(results),
            percentiles: {
                p95: this.percentile(results, 95),
                p99: this.percentile(results, 99)
            },
            memoryUsed: memoryAfter.used - memoryBefore.used,
            timestamp: Date.now()
        };

        this.benchmarks.set(name, stats);
        return stats;
    }

    // 获取内存使用情况
    getMemoryUsage() {
        if (performance.memory) {
            return {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            };
        }
        return { used: 0, total: 0, limit: 0 };
    }

    // 计算中位数
    median(values) {
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0 ?
            (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }

    // 计算百分位数
    percentile(values, p) {
        const sorted = [...values].sort((a, b) => a - b);
        const index = Math.ceil((p / 100) * sorted.length) - 1;
        return sorted[index] || 0;
    }

    // 获取性能报告
    getPerformanceReport() {
        const report = {
            timestamp: Date.now(),
            metrics: {},
            benchmarks: {},
            alerts: this.alerts.slice(-20),
            coreWebVitals: this.getCoreWebVitals(),
            recommendations: this.generateRecommendations()
        };

        // 聚合指标
        for (const [name, values] of this.metrics) {
            if (values.length > 0) {
                report.metrics[name] = {
                    latest: values[values.length - 1],
                    average: values.reduce((sum, m) => sum + m.value, 0) / values.length,
                    trend: this.calculateTrend(values),
                    count: values.length
                };
            }
        }

        // 添加基准测试结果
        for (const [name, stats] of this.benchmarks) {
            report.benchmarks[name] = stats;
        }

        return report;
    }

    // 获取核心 Web 指标
    getCoreWebVitals() {
        return {
            fcp: this.getLatestMetric('first-contentful-paint'),
            lcp: this.getLatestMetric('largest-contentful-paint'),
            fid: this.getLatestMetric('first-input-delay'),
            cls: this.getLatestMetric('cumulative-layout-shift'),
            tti: this.getLatestMetric('time-to-interactive')
        };
    }

    // 获取最新指标
    getLatestMetric(name) {
        const values = this.metrics.get(name);
        return values ? values[values.length - 1] : null;
    }

    // 计算趋势
    calculateTrend(values) {
        if (values.length < 2) return 'stable';

        const recent = values.slice(-10);
        const avgRecent = recent.reduce((sum, m) => sum + m.value, 0) / recent.length;
        const older = values.slice(-20, -10);
        const avgOlder = older.length > 0 ?
            older.reduce((sum, m) => sum + m.value, 0) / older.length : avgRecent;

        const change = ((avgRecent - avgOlder) / avgOlder) * 100;

        if (Math.abs(change) < 5) return 'stable';
        return change > 0 ? 'increasing' : 'decreasing';
    }

    // 生成优化建议
    generateRecommendations() {
        const recommendations = [];

        // 分析 Web Vitals
        const vitals = this.getCoreWebVitals();
        if (vitals.lcp && vitals.lcp.value > this.thresholds.largestContentfulPaint) {
            recommendations.push({
                type: 'lcp',
                message: 'LCP 过长，建议优化图片大小、减少阻塞渲染的资源',
                severity: 'high'
            });
        }

        if (vitals.fid && vitals.fid.value > this.thresholds.firstInputDelay) {
            recommendations.push({
                type: 'fid',
                message: 'FID 过长，建议减少主线程任务、优化 JavaScript 执行',
                severity: 'high'
            });
        }

        if (vitals.cls && vitals.cls.value > this.thresholds.cumulativeLayoutShift) {
            recommendations.push({
                type: 'cls',
                message: 'CLS 过高，建议为图片和广告预留空间、避免动态内容',
                severity: 'medium'
            });
        }

        // 分析内存使用
        const memoryUsage = this.getMemoryUsage();
        if (memoryUsage.used > this.thresholds.memoryLeakThreshold) {
            recommendations.push({
                type: 'memory',
                message: '内存使用过高，建议检查内存泄漏',
                severity: 'high'
            });
        }

        return recommendations;
    }
}

// 使用示例
const metrics = new PerformanceMetrics();

// 记录 Web Vitals
if ('PerformanceObserver' in window) {
    const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
            metrics.recordMetric(entry.name, entry.value, entry.entryType);
        }
    });

    observer.observe({ entryTypes: ['paint', 'largest-contentful-paint', 'first-input', 'layout-shift'] });
}

// 基准测试示例
const benchmarkResults = metrics.benchmark('array-operations', () => {
    const arr = new Array(1000).fill(0).map((_, i) => i);
    return arr.filter(x => x % 2 === 0).map(x => x * 2);
}, 1000);

console.log('基准测试结果:', benchmarkResults);

// 获取性能报告
const report = metrics.getPerformanceReport();
console.log('性能报告:', report);
```

### 性能分析工具

```javascript
// 高级性能分析器
class PerformanceProfiler {
    constructor() {
        this.profiles = new Map();
        this.activeProfiles = new Set();
        this.callStacks = new Map();
        this.memorySnapshots = [];
        this.frameMetrics = [];
    }

    // 开始性能分析
    startProfile(name) {
        const profile = {
            name: name,
            startTime: performance.now(),
            samples: [],
            markers: [],
            memory: [],
            stackTraces: [],
            isActive: true
        };

        this.profiles.set(name, profile);
        this.activeProfiles.add(name);

        // 开始内存监控
        if (performance.memory) {
            this.startMemoryMonitoring(name);
        }

        // 开始帧监控
        this.startFrameMonitoring(name);

        console.log(`开始性能分析: ${name}`);
        return name;
    }

    // 结束性能分析
    endProfile(name) {
        const profile = this.profiles.get(name);
        if (!profile || !profile.isActive) {
            console.warn(`性能分析不存在或已结束: ${name}`);
            return null;
        }

        profile.endTime = performance.now();
        profile.duration = profile.endTime - profile.startTime;
        profile.isActive = false;
        this.activeProfiles.delete(name);

        // 停止监控
        this.stopMemoryMonitoring(name);
        this.stopFrameMonitoring(name);

        // 分析结果
        const analysis = this.analyzeProfile(profile);
        profile.analysis = analysis;

        console.log(`性能分析完成: ${name}, 耗时: ${profile.duration.toFixed(2)}ms`);
        return profile;
    }

    // 记录性能样本
    recordSample(name, data) {
        const profile = this.profiles.get(name);
        if (!profile || !profile.isActive) return;

        profile.samples.push({
            timestamp: performance.now() - profile.startTime,
            data: data,
            memory: this.getMemoryUsage()
        });
    }

    // 添加标记
    addMarker(name, label, data = {}) {
        const profile = this.profiles.get(name);
        if (!profile || !profile.isActive) return;

        profile.markers.push({
            timestamp: performance.now() - profile.startTime,
            label: label,
            data: data
        });
    }

    // 内存监控
    startMemoryMonitoring(name) {
        const profile = this.profiles.get(name);
        if (!profile) return;

        const intervalId = setInterval(() => {
            if (profile.isActive) {
                profile.memory.push({
                    timestamp: performance.now() - profile.startTime,
                    ...this.getMemoryUsage()
                });
            }
        }, 100);

        profile.memoryIntervalId = intervalId;
    }

    stopMemoryMonitoring(name) {
        const profile = this.profiles.get(name);
        if (profile && profile.memoryIntervalId) {
            clearInterval(profile.memoryIntervalId);
        }
    }

    // 帧监控
    startFrameMonitoring(name) {
        const profile = this.profiles.get(name);
        if (!profile) return;

        let lastFrameTime = performance.now();
        const frameData = [];

        const measureFrame = (timestamp) => {
            if (!profile.isActive) return;

            const frameTime = timestamp - lastFrameTime;
            frameData.push(frameTime);

            // 保持最近100帧的数据
            if (frameData.length > 100) {
                frameData.shift();
            }

            profile.frameMetrics = {
                frames: frameData,
                fps: 1000 / (frameData.reduce((a, b) => a + b, 0) / frameData.length),
                droppedFrames: frameData.filter(time => time > 16.67).length
            };

            lastFrameTime = timestamp;
            requestAnimationFrame(measureFrame);
        };

        profile.frameRequestId = requestAnimationFrame(measureFrame);
    }

    stopFrameMonitoring(name) {
        const profile = this.profiles.get(name);
        if (profile && profile.frameRequestId) {
            cancelAnimationFrame(profile.frameRequestId);
        }
    }

    // 分析性能档案
    analyzeProfile(profile) {
        const analysis = {
            duration: profile.duration,
            sampleCount: profile.samples.length,
            markers: profile.markers.length,
            memory: this.analyzeMemory(profile.memory),
            frames: this.analyzeFrames(profile.frameMetrics),
            bottlenecks: this.identifyBottlenecks(profile),
            recommendations: this.generateProfileRecommendations(profile)
        };

        return analysis;
    }

    // 分析内存使用
    analyzeMemory(memoryData) {
        if (memoryData.length === 0) return null;

        const usedMemory = memoryData.map(m => m.used);
        const totalMemory = memoryData.map(m => m.total);

        return {
            minUsed: Math.min(...usedMemory),
            maxUsed: Math.max(...usedMemory),
            avgUsed: usedMemory.reduce((a, b) => a + b, 0) / usedMemory.length,
            memoryGrowth: usedMemory[usedMemory.length - 1] - usedMemory[0],
            fragmentation: this.calculateFragmentation(memoryData)
        };
    }

    // 计算内存碎片率
    calculateFragmentation(memoryData) {
        if (memoryData.length < 2) return 0;

        const totalGrowth = memoryData[memoryData.length - 1].total -
                          memoryData[0].total;
        const usedGrowth = memoryData[memoryData.length - 1].used -
                         memoryData[0].used;

        return totalGrowth > 0 ? (totalGrowth - usedGrowth) / totalGrowth : 0;
    }

    // 分析帧性能
    analyzeFrames(frameMetrics) {
        if (!frameMetrics) return null;

        return {
            fps: frameMetrics.fps,
            droppedFrames: frameMetrics.droppedFrames,
            frameTimePercentiles: {
                p50: this.percentile(frameMetrics.frames, 50),
                p95: this.percentile(frameMetrics.frames, 95),
                p99: this.percentile(frameMetrics.frames, 99)
            }
        };
    }

    // 识别性能瓶颈
    identifyBottlenecks(profile) {
        const bottlenecks = [];

        // 检查内存问题
        const memoryAnalysis = this.analyzeMemory(profile.memory);
        if (memoryAnalysis && memoryAnalysis.memoryGrowth > 1024 * 1024 * 10) {
            bottlenecks.push({
                type: 'memory',
                severity: 'high',
                message: `内存增长过快: ${(memoryAnalysis.memoryGrowth / 1024 / 1024).toFixed(2)}MB`
            });
        }

        // 检查帧率问题
        const frameAnalysis = this.analyzeFrames(profile.frameMetrics);
        if (frameAnalysis && frameAnalysis.fps < 30) {
            bottlenecks.push({
                type: 'fps',
                severity: 'high',
                message: `帧率过低: ${frameAnalysis.fps.toFixed(1)} FPS`
            });
        }

        // 检查执行时间
        if (profile.duration > 5000) {
            bottlenecks.push({
                type: 'duration',
                severity: 'medium',
                message: `执行时间过长: ${profile.duration.toFixed(2)}ms`
            });
        }

        return bottlenecks;
    }

    // 生成性能建议
    generateProfileRecommendations(profile) {
        const recommendations = [];

        const bottlenecks = this.identifyBottlenecks(profile);
        bottlenecks.forEach(bottleneck => {
            switch (bottleneck.type) {
                case 'memory':
                    recommendations.push({
                        type: 'memory',
                        message: '建议检查内存泄漏，优化数据结构和算法'
                    });
                    break;
                case 'fps':
                    recommendations.push({
                        type: 'rendering',
                        message: '建议优化渲染逻辑，减少 DOM 操作，使用 requestAnimationFrame'
                    });
                    break;
                case 'duration':
                    recommendations.push({
                        type: 'algorithm',
                        message: '建议优化算法复杂度，考虑使用 Web Workers'
                    });
                    break;
            }
        });

        return recommendations;
    }

    // 获取内存使用情况
    getMemoryUsage() {
        if (performance.memory) {
            return {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            };
        }
        return { used: 0, total: 0, limit: 0 };
    }

    // 计算百分位数
    percentile(values, p) {
        const sorted = [...values].sort((a, b) => a - b);
        const index = Math.ceil((p / 100) * sorted.length) - 1;
        return sorted[index] || 0;
    }

    // 获取所有性能档案
    getAllProfiles() {
        return Array.from(this.profiles.values());
    }

    // 获取性能摘要
    getPerformanceSummary() {
        const profiles = this.getAllProfiles();
        const summary = {
            totalProfiles: profiles.length,
            activeProfiles: this.activeProfiles.size,
            averageDuration: 0,
            totalDuration: 0,
            bottlenecks: []
        };

        if (profiles.length > 0) {
            summary.totalDuration = profiles.reduce((sum, p) => sum + (p.duration || 0), 0);
            summary.averageDuration = summary.totalDuration / profiles.length;

            profiles.forEach(profile => {
                if (profile.analysis) {
                    summary.bottlenecks.push(...profile.analysis.bottlenecks);
                }
            });
        }

        return summary;
    }
}

// 使用示例
const profiler = new PerformanceProfiler();

// 性能分析示例
function testPerformanceProfiling() {
    console.log("测试性能分析...");

    // 开始分析
    const profileName = profiler.startProfile('complex-operation');

    // 添加标记
    profiler.addMarker(profileName, 'start-data-processing');

    // 模拟复杂操作
    setTimeout(() => {
        profiler.addMarker(profileName, 'data-loaded');

        // 模拟计算密集型任务
        let result = 0;
        for (let i = 0; i < 1000000; i++) {
            result += Math.sqrt(i) * Math.sin(i);
        }

        profiler.addMarker(profileName, 'computation-complete');

        // 模拟 DOM 操作
        const div = document.createElement('div');
        div.innerHTML = 'Test';
        document.body.appendChild(div);

        profiler.addMarker(profileName, 'dom-updated');

        // 结束分析
        const profile = profiler.endProfile(profileName);

        console.log('性能分析结果:', profile.analysis);

        // 清理
        document.body.removeChild(div);
    }, 100);
}

// testPerformanceProfiling();
```

## 代码优化技术

### 算法复杂度优化

```javascript
// 算法复杂度分析器
class ComplexityAnalyzer {
    constructor() {
        this.testCases = new Map();
        this.results = new Map();
    }

    // 测试算法复杂度
    testComplexity(algorithmName, algorithm, testSizes) {
        const results = [];

        for (const size of testSizes) {
            const testData = this.generateTestData(size);
            const start = performance.now();
            const result = algorithm(testData);
            const end = performance.now();
            const duration = end - start;

            results.push({
                size: size,
                duration: duration,
                result: result,
                memory: this.measureMemoryUsage(() => algorithm(testData))
            });
        }

        const analysis = this.analyzeComplexity(algorithmName, results);
        this.results.set(algorithmName, { results, analysis });

        return analysis;
    }

    // 生成测试数据
    generateTestData(size) {
        return Array.from({ length: size }, (_, i) => ({
            id: i,
            value: Math.random() * 1000,
            name: `item_${i}`
        }));
    }

    // 测量内存使用
    measureMemoryUsage(fn) {
        if (!performance.memory) return 0;

        const before = performance.memory.usedJSHeapSize;
        fn();
        const after = performance.memory.usedJSHeapSize;
        return after - before;
    }

    // 分析复杂度
    analyzeComplexity(algorithmName, results) {
        const n = results.map(r => r.size);
        const t = results.map(r => r.duration);

        // 计算增长率
        const growthRates = [];
        for (let i = 1; i < results.length; i++) {
            const sizeGrowth = n[i] / n[i - 1];
            const timeGrowth = t[i] / t[i - 1];
            growthRates.push({ size: n[i], timeGrowth, sizeGrowth });
        }

        // 推断复杂度
        const complexity = this.inferComplexity(growthRates);

        // 计算拟合度
        const fittedCurve = this.fitComplexityCurve(complexity, n, t);
        const rSquared = this.calculateRSquared(t, fittedCurve);

        return {
            algorithm: algorithmName,
            complexity: complexity,
            growthRates: growthRates,
            rSquared: rSquared,
            performance: this.calculatePerformanceMetrics(results),
            recommendations: this.generateOptimizationRecommendations(complexity, results)
        };
    }

    // 推断复杂度
    inferComplexity(growthRates) {
        const avgTimeGrowth = growthRates.reduce((sum, r) => sum + r.timeGrowth, 0) / growthRates.length;
        const avgSizeGrowth = growthRates.reduce((sum, r) => sum + r.sizeGrowth, 0) / growthRates.length;

        if (avgTimeGrowth < 1.2) return 'O(1)';
        if (avgTimeGrowth < 2.5) return 'O(log n)';
        if (avgTimeGrowth < 4) return 'O(n)';
        if (avgTimeGrowth < 8) return 'O(n log n)';
        if (avgTimeGrowth < 16) return 'O(n²)';
        return 'O(n³) 或更高';
    }

    // 拟合复杂度曲线
    fitComplexityCurve(complexity, n, t) {
        switch (complexity) {
            case 'O(1)':
                return t.map(() => t[0]);
            case 'O(log n)':
                return t.map((_, i) => t[0] * Math.log(n[i] + 1) / Math.log(n[0] + 1));
            case 'O(n)':
                return t.map((_, i) => t[0] * n[i] / n[0]);
            case 'O(n log n)':
                return t.map((_, i) => t[0] * n[i] * Math.log(n[i] + 1) / (n[0] * Math.log(n[0] + 1)));
            case 'O(n²)':
                return t.map((_, i) => t[0] * Math.pow(n[i] / n[0], 2));
            default:
                return t;
        }
    }

    // 计算 R² 值
    calculateRSquared(actual, predicted) {
        const mean = actual.reduce((sum, val) => sum + val, 0) / actual.length;
        const totalSumSquares = actual.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
        const residualSumSquares = actual.reduce((sum, val, i) => {
            return sum + Math.pow(val - predicted[i], 2);
        }, 0);

        return 1 - (residualSumSquares / totalSumSquares);
    }

    // 计算性能指标
    calculatePerformanceMetrics(results) {
        const durations = results.map(r => r.duration);
        const memory = results.map(r => r.memory);

        return {
            minTime: Math.min(...durations),
            maxTime: Math.max(...durations),
            avgTime: durations.reduce((a, b) => a + b, 0) / durations.length,
            minMemory: Math.min(...memory),
            maxMemory: Math.max(...memory),
            avgMemory: memory.reduce((a, b) => a + b, 0) / memory.length,
            timeToFirstResult: durations[0]
        };
    }

    // 生成优化建议
    generateOptimizationRecommendations(complexity, results) {
        const recommendations = [];

        switch (complexity) {
            case 'O(n²)':
            case 'O(n³) 或更高':
                recommendations.push({
                    type: 'algorithm',
                    message: '算法复杂度过高，建议考虑更高效的算法',
                    suggestions: [
                        '使用哈希表替代嵌套循环',
                        '考虑排序后使用二分查找',
                        '使用动态规划或贪心算法'
                    ]
                });
                break;
            case 'O(n log n)':
                recommendations.push({
                    type: 'optimization',
                    message: '算法复杂度良好，但仍有优化空间',
                    suggestions: [
                        '使用更高效的排序算法',
                        '考虑使用内置优化方法'
                    ]
                });
                break;
            case 'O(n)':
                recommendations.push({
                    type: 'memory',
                    message: '线性复杂度，主要关注内存使用',
                    suggestions: [
                        '使用流式处理减少内存占用',
                        '考虑使用生成器函数'
                    ]
                });
                break;
        }

        // 内存优化建议
        const maxMemory = Math.max(...results.map(r => r.memory));
        if (maxMemory > 1024 * 1024 * 10) { // 10MB
            recommendations.push({
                type: 'memory',
                message: '内存使用较高，建议优化',
                suggestions: [
                    '使用对象池减少垃圾回收',
                    '避免深拷贝大型对象',
                    '使用 TypedArray 优化数值数组'
                ]
            });
        }

        return recommendations;
    }

    // 比较算法性能
    compareAlgorithms(algorithms, testSizes) {
        const comparisons = [];

        for (const [name, algorithm] of algorithms) {
            const analysis = this.testComplexity(name, algorithm, testSizes);
            comparisons.push({ name, analysis });
        }

        // 按性能排序
        comparisons.sort((a, b) => {
            const aTime = a.analysis.performance.avgTime;
            const bTime = b.analysis.performance.avgTime;
            return aTime - bTime;
        });

        return {
            comparisons: comparisons,
            winner: comparisons[0],
            recommendations: this.generateComparisonRecommendations(comparisons)
        };
    }

    // 生成比较建议
    generateComparisonRecommendations(comparisons) {
        const recommendations = [];

        if (comparisons.length > 1) {
            const fastest = comparisons[0];
            const slowest = comparisons[comparisons.length - 1];

            const speedup = slowest.analysis.performance.avgTime / fastest.analysis.performance.avgTime;

            recommendations.push({
                type: 'selection',
                message: `${fastest.name} 是最快的算法，比 ${slowest.name} 快 ${speedup.toFixed(2)} 倍`,
                bestChoice: fastest.name
            });

            // 分析复杂度差异
            if (fastest.analysis.complexity !== slowest.analysis.complexity) {
                recommendations.push({
                    type: 'complexity',
                    message: `复杂度差异显著：${fastest.name} (${fastest.analysis.complexity}) vs ${slowest.name} (${slowest.analysis.complexity})`
                });
            }
        }

        return recommendations;
    }
}

// 使用示例
const complexityAnalyzer = new ComplexityAnalyzer();

// 测试不同算法
const algorithms = {
    'linear-search': (data) => {
        const target = data[Math.floor(data.length / 2)];
        return data.findIndex(item => item.id === target.id);
    },

    'binary-search': (data) => {
        const sorted = [...data].sort((a, b) => a.id - b.id);
        const target = sorted[Math.floor(sorted.length / 2)];
        return this.binarySearch(sorted, target.id);
    },

    'hash-lookup': (data) => {
        const map = new Map(data.map(item => [item.id, item]));
        const target = data[Math.floor(data.length / 2)];
        return map.has(target.id);
    }
};

// 添加二分查找方法
complexityAnalyzer.binarySearch = (array, target) => {
    let left = 0;
    let right = array.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (array[mid].id === target) return mid;
        if (array[mid].id < target) left = mid + 1;
        else right = mid - 1;
    }

    return -1;
};

// 测试不同数据规模
const testSizes = [100, 1000, 5000, 10000, 20000];

const comparison = complexityAnalyzer.compareAlgorithms(algorithms, testSizes);
console.log('算法比较结果:', comparison);
```

### 内存优化技术

```javascript
// 高级内存优化器
class MemoryOptimizer {
    constructor() {
        this.objectPools = new Map();
        this.weakReferences = new Map();
        this.memorySnapshots = [];
        this.allocationTrackers = new Map();
        this.optimizations = new Map();
    }

    // 创建对象池
    createObjectPool(constructor, initialSize = 10, maxSize = 100) {
        const pool = {
            constructor: constructor,
            objects: [],
            maxSize: maxSize,
            allocated: 0,
            recycled: 0,

            acquire: function() {
                if (this.objects.length > 0) {
                    this.allocated++;
                    return this.objects.pop();
                } else {
                    return new constructor();
                }
            },

            release: function(obj) {
                if (this.objects.length < this.maxSize) {
                    this.resetObject(obj);
                    this.objects.push(obj);
                    this.recycled++;
                }
            },

            resetObject: function(obj) {
                // 重置对象状态
                if (typeof obj.reset === 'function') {
                    obj.reset();
                } else {
                    for (const key in obj) {
                        if (obj.hasOwnProperty(key) && typeof obj[key] !== 'function') {
                            delete obj[key];
                        }
                    }
                }
            },

            getStats: function() {
                return {
                    poolSize: this.objects.length,
                    allocated: this.allocated,
                    recycled: this.recycled,
                    efficiency: this.recycled / (this.allocated + this.recycled) || 0
                };
            },

            clear: function() {
                this.objects = [];
                this.allocated = 0;
                this.recycled = 0;
            }
        };

        // 预分配对象
        for (let i = 0; i < initialSize; i++) {
            pool.objects.push(new constructor());
        }

        const poolId = constructor.name || 'anonymous';
        this.objectPools.set(poolId, pool);

        return pool;
    }

    // 创建弱引用缓存
    createWeakCache(maxSize = 1000) {
        const cache = new Map();
        const weakRefs = new Map();
        let accessOrder = [];

        return {
            get: function(key) {
                const weakRef = weakRefs.get(key);
                if (weakRef) {
                    const value = weakRef.deref();
                    if (value !== undefined) {
                        // 更新访问顺序
                        accessOrder = accessOrder.filter(k => k !== key);
                        accessOrder.push(key);
                        return value;
                    } else {
                        weakRefs.delete(key);
                        cache.delete(key);
                    }
                }
                return null;
            },

            set: function(key, value) {
                // 检查大小限制
                if (accessOrder.length >= maxSize) {
                    const oldestKey = accessOrder.shift();
                    weakRefs.delete(oldestKey);
                    cache.delete(oldestKey);
                }

                cache.set(key, value);
                accessOrder.push(key);

                if (typeof WeakRef !== 'undefined') {
                    weakRefs.set(key, new WeakRef(value));
                }
            },

            has: function(key) {
                return cache.has(key) && this.get(key) !== null;
            },

            delete: function(key) {
                weakRefs.delete(key);
                cache.delete(key);
                accessOrder = accessOrder.filter(k => k !== key);
            },

            clear: function() {
                weakRefs.clear();
                cache.clear();
                accessOrder = [];
            },

            size: function() {
                return cache.size;
            },

            getStats: function() {
                return {
                    size: this.size(),
                    hitRate: this.calculateHitRate(),
                    memoryEfficiency: this.calculateMemoryEfficiency()
                };
            },

            calculateHitRate: function() {
                // 简化的命中率计算
                return 0.8; // 实际实现需要跟踪访问统计
            },

            calculateMemoryEfficiency: function() {
                return weakRefs.size / (cache.size + 1);
            }
        };
    }

    // 内存映射优化
    createMemoryMappedArray(initialSize = 1024) {
        const buffer = new ArrayBuffer(initialSize);
        const dataView = new DataView(buffer);
        let offset = 0;

        return {
            writeInt8: function(value) {
                if (offset + 1 > buffer.byteLength) {
                    this.expandBuffer(1);
                }
                dataView.setInt8(offset, value);
                offset += 1;
                return this;
            },

            writeInt16: function(value) {
                if (offset + 2 > buffer.byteLength) {
                    this.expandBuffer(2);
                }
                dataView.setInt16(offset, value, true);
                offset += 2;
                return this;
            },

            writeInt32: function(value) {
                if (offset + 4 > buffer.byteLength) {
                    this.expandBuffer(4);
                }
                dataView.setInt32(offset, value, true);
                offset += 4;
                return this;
            },

            writeFloat32: function(value) {
                if (offset + 4 > buffer.byteLength) {
                    this.expandBuffer(4);
                }
                dataView.setFloat32(offset, value, true);
                offset += 4;
                return this;
            },

            writeFloat64: function(value) {
                if (offset + 8 > buffer.byteLength) {
                    this.expandBuffer(8);
                }
                dataView.setFloat64(offset, value, true);
                offset += 8;
                return this;
            },

            writeString: function(str) {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(str);
                if (offset + bytes.length + 4 > buffer.byteLength) {
                    this.expandBuffer(bytes.length + 4);
                }
                this.writeInt32(bytes.length);
                new Uint8Array(buffer, offset, bytes.length).set(bytes);
                offset += bytes.length;
                return this;
            },

            readInt8: function() {
                const value = dataView.getInt8(offset);
                offset += 1;
                return value;
            },

            readInt16: function() {
                const value = dataView.getInt16(offset, true);
                offset += 2;
                return value;
            },

            readInt32: function() {
                const value = dataView.getInt32(offset, true);
                offset += 4;
                return value;
            },

            readFloat32: function() {
                const value = dataView.getFloat32(offset, true);
                offset += 4;
                return value;
            },

            readFloat64: function() {
                const value = dataView.getFloat64(offset, true);
                offset += 8;
                return value;
            },

            readString: function() {
                const length = this.readInt32();
                const bytes = new Uint8Array(buffer, offset, length);
                const decoder = new TextDecoder();
                const str = decoder.decode(bytes);
                offset += length;
                return str;
            },

            expandBuffer: function(minRequired) {
                const newSize = Math.max(buffer.byteLength * 2, buffer.byteLength + minRequired);
                const newBuffer = new ArrayBuffer(newSize);
                const newView = new DataView(newBuffer);
                new Uint8Array(newBuffer).set(new Uint8Array(buffer));
                buffer = newBuffer;
                dataView = newView;
            },

            reset: function() {
                offset = 0;
            },

            getPosition: function() {
                return offset;
            },

            getBuffer: function() {
                return buffer;
            },

            getSize: function() {
                return buffer.byteLength;
            }
        };
    }

    // 内存分配追踪器
    createAllocationTracker() {
        const allocations = new Map();
        const stackTraces = new Map();
        let totalAllocated = 0;
        let totalFreed = 0;

        return {
            trackAllocation: function(obj, size, stack) {
                const id = this.getObjectId(obj);
                const allocation = {
                    id: id,
                    object: obj,
                    size: size,
                    stack: stack,
                    allocatedAt: Date.now(),
                    freedAt: null,
                    references: new Set()
                };

                allocations.set(id, allocation);
                stackTraces.set(id, stack);
                totalAllocated += size;

                return id;
            },

            trackDeallocation: function(obj) {
                const id = this.getObjectId(obj);
                const allocation = allocations.get(id);

                if (allocation) {
                    allocation.freedAt = Date.now();
                    totalFreed += allocation.size;
                }
            },

            trackReference: function(fromId, toId) {
                const fromAllocation = allocations.get(fromId);
                const toAllocation = allocations.get(toId);

                if (fromAllocation && toAllocation) {
                    fromAllocation.references.add(toId);
                }
            },

            findMemoryLeaks: function() {
                const leaks = [];
                const now = Date.now();

                for (const [id, allocation] of allocations) {
                    if (!allocation.freedAt) {
                        const lifetime = now - allocation.allocatedAt;
                        if (lifetime > 30000 && allocation.references.size === 0) { // 30秒
                            leaks.push({
                                id: id,
                                size: allocation.size,
                                lifetime: lifetime,
                                stack: stackTraces.get(id)
                            });
                        }
                    }
                }

                return leaks.sort((a, b) => b.size - a.size);
            },

            getMemoryStats: function() {
                return {
                    totalAllocated: totalAllocated,
                    totalFreed: totalFreed,
                    currentUsage: totalAllocated - totalFreed,
                    allocationCount: allocations.size,
                    leakCount: this.findMemoryLeaks().length
                };
            },

            getObjectId: function(obj) {
                return `${obj.constructor.name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
        };
    }

    // 延迟加载优化
    createLazyLoader(factory) {
        let loaded = false;
        let value = null;
        let error = null;
        const pendingPromises = [];

        return {
            get: function() {
                if (loaded) {
                    if (error) {
                        return Promise.reject(error);
                    }
                    return Promise.resolve(value);
                }

                const promise = new Promise((resolve, reject) => {
                    pendingPromises.push({ resolve, reject });
                });

                if (pendingPromises.length === 1) {
                    factory()
                        .then(result => {
                            loaded = true;
                            value = result;
                            pendingPromises.forEach(p => p.resolve(result));
                            pendingPromises.length = 0;
                        })
                        .catch(err => {
                            loaded = true;
                            error = err;
                            pendingPromises.forEach(p => p.reject(err));
                            pendingPromises.length = 0;
                        });
                }

                return promise;
            },

            isLoaded: function() {
                return loaded;
            },

            reset: function() {
                loaded = false;
                value = null;
                error = null;
            },

            getValueSync: function() {
                if (!loaded) {
                    throw new Error('Value not loaded yet');
                }
                if (error) {
                    throw error;
                }
                return value;
            }
        };
    }

    // 内存快照比较
    takeMemorySnapshot() {
        const snapshot = {
            timestamp: Date.now(),
            memory: this.getMemoryUsage(),
            allocations: this.getAllocationStats(),
            objectPools: this.getPoolStats(),
            caches: this.getCacheStats()
        };

        this.memorySnapshots.push(snapshot);

        // 保持最近20个快照
        if (this.memorySnapshots.length > 20) {
            this.memorySnapshots.shift();
        }

        return snapshot;
    }

    // 比较内存快照
    compareSnapshots(before, after) {
        if (!before || !after) return null;

        return {
            timeDiff: after.timestamp - before.timestamp,
            memoryGrowth: after.memory.used - before.memory.used,
            allocationGrowth: after.allocations.total - before.allocations.total,
            poolEfficiency: this.calculatePoolEfficiency(before, after),
            recommendations: this.generateMemoryRecommendations(before, after)
        };
    }

    // 计算对象池效率
    calculatePoolEfficiency(before, after) {
        const efficiency = {};

        for (const [name, afterStats] of Object.entries(after.objectPools)) {
            const beforeStats = before.objectPools[name];
            if (beforeStats) {
                efficiency[name] = {
                    recycleRate: (afterStats.recycled - beforeStats.recycled) /
                                 (afterStats.allocated - beforeStats.allocated),
                    spaceSaved: (afterStats.recycled - beforeStats.recycled) *
                                (beforeStats.constructor.size || 100)
                };
            }
        }

        return efficiency;
    }

    // 生成内存优化建议
    generateMemoryRecommendations(before, after) {
        const recommendations = [];
        const growth = after.memory.used - before.memory.used;

        if (growth > 1024 * 1024 * 10) { // 10MB
            recommendations.push({
                type: 'memory_growth',
                severity: 'high',
                message: `内存增长过快: ${(growth / 1024 / 1024).toFixed(2)}MB`,
                suggestions: [
                    '检查内存泄漏',
                    '使用对象池减少垃圾回收',
                    '优化数据结构'
                ]
            });
        }

        // 检查对象池效率
        const poolEfficiency = this.calculatePoolEfficiency(before, after);
        for (const [name, stats] of Object.entries(poolEfficiency)) {
            if (stats.recycleRate < 0.5) {
                recommendations.push({
                    type: 'pool_efficiency',
                    severity: 'medium',
                    message: `对象池 ${name} 回收率较低: ${(stats.recycleRate * 100).toFixed(1)}%`,
                    suggestions: [
                        '调整对象池大小',
                        '检查对象使用模式'
                    ]
                });
            }
        }

        return recommendations;
    }

    // 获取内存使用情况
    getMemoryUsage() {
        if (performance.memory) {
            return {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            };
        }
        return { used: 0, total: 0, limit: 0 };
    }

    // 获取分配统计
    getAllocationStats() {
        let total = 0;
        let count = 0;

        for (const tracker of this.allocationTrackers.values()) {
            const stats = tracker.getMemoryStats();
            total += stats.totalAllocated;
            count += stats.allocationCount;
        }

        return { total, count };
    }

    // 获取对象池统计
    getPoolStats() {
        const stats = {};
        for (const [name, pool] of this.objectPools) {
            stats[name] = pool.getStats();
        }
        return stats;
    }

    // 获取缓存统计
    getCacheStats() {
        const stats = {};
        for (const [name, cache] of this.weakReferences) {
            stats[name] = cache.getStats();
        }
        return stats;
    }

    // 获取优化摘要
    getOptimizationSummary() {
        return {
            objectPools: this.objectPools.size,
            weakCaches: this.weakReferences.size,
            memorySnapshots: this.memorySnapshots.length,
            totalMemorySaved: this.calculateTotalMemorySaved(),
            recommendations: this.generateOverallRecommendations()
        };
    }

    // 计算总内存节省
    calculateTotalMemorySaved() {
        let saved = 0;
        for (const pool of this.objectPools.values()) {
            const stats = pool.getStats();
            saved += stats.recycled * 100; // 估算每个对象100字节
        }
        return saved;
    }

    // 生成总体建议
    generateOverallRecommendations() {
        const recommendations = [];

        if (this.objectPools.size === 0) {
            recommendations.push({
                type: 'object_pools',
                message: '建议使用对象池减少垃圾回收开销'
            });
        }

        if (this.weakReferences.size === 0) {
            recommendations.push({
                type: 'weak_references',
                message: '建议使用弱引用缓存减少内存占用'
            });
        }

        return recommendations;
    }
}

// 使用示例
const memoryOptimizer = new MemoryOptimizer();

// 创建对象池
class Vector3 {
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    reset() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
}

const vectorPool = memoryOptimizer.createObjectPool(Vector3, 50);

// 使用对象池
const v1 = vectorPool.acquire();
v1.x = 10;
v1.y = 20;
v1.z = 30;

console.log('Vector3:', v1);

vectorPool.release(v1);

// 创建弱引用缓存
const weakCache = memoryOptimizer.createWeakCache(1000);

// 使用缓存
weakCache.set('key1', { data: 'value1' });
weakCache.set('key2', { data: 'value2' });

console.log('缓存命中:', weakCache.get('key1'));
console.log('缓存统计:', weakCache.getStats());

// 内存映射数组
const memArray = memoryOptimizer.createMemoryMappedArray(1024);

memArray.writeInt32(42);
memArray.writeString('Hello World');
memArray.writeFloat64(3.14159);

memArray.reset();

const readInt = memArray.readInt32();
const readStr = memArray.readString();
const readFloat = memArray.readFloat64();

console.log('内存映射读取:', { readInt, readStr, readFloat });

// 优化摘要
console.log('优化摘要:', memoryOptimizer.getOptimizationSummary());
```

## 调试技术与工具

### 高级调试器

```javascript
// 高级调试工具
class AdvancedDebugger {
    constructor() {
        this.breakpoints = new Map();
        this.watchExpressions = new Map();
        this.callStack = [];
        this.executionHistory = [];
        this.debugSessions = new Map();
    }

    // 设置断点
    setBreakpoint(fileName, lineNumber, condition = null) {
        const breakpointId = `${fileName}:${lineNumber}`;
        this.breakpoints.set(breakpointId, {
            fileName: fileName,
            lineNumber: lineNumber,
            condition: condition,
            hitCount: 0,
            enabled: true,
            created: Date.now()
        });

        console.log(`设置断点: ${breakpointId}`);
        return breakpointId;
    }

    // 移除断点
    removeBreakpoint(breakpointId) {
        return this.breakpoints.delete(breakpointId);
    }

    // 添加监视表达式
    addWatchExpression(expression, scope = 'global') {
        const watchId = Date.now().toString();
        this.watchExpressions.set(watchId, {
            expression: expression,
            scope: scope,
            value: null,
            error: null,
            lastEvaluated: null
        });

        console.log(`添加监视表达式: ${expression}`);
        return watchId;
    }

    // 移除监视表达式
    removeWatchExpression(watchId) {
        return this.watchExpressions.delete(watchId);
    }

    // 评估表达式
    evaluateExpression(expression, context = {}) {
        try {
            // 创建安全的评估环境
            const safeEval = new Function('context', `
                "use strict";
                with(context) {
                    return ${expression};
                }
            `);

            const result = safeEval(context);
            return { success: true, result: result };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    // 创建调试会话
    createDebugSession(name) {
        const session = {
            name: name,
            startTime: Date.now(),
            breakpoints: new Set(),
            watchExpressions: new Set(),
            variables: new Map(),
            callStack: [],
            state: 'running',
            logs: []
        };

        this.debugSessions.set(name, session);
        console.log(`创建调试会话: ${name}`);
        return session;
    }

    // 开始调试
    startDebugging(sessionName, code) {
        const session = this.debugSessions.get(sessionName);
        if (!session) {
            throw new Error(`调试会话不存在: ${sessionName}`);
        }

        session.state = 'debugging';
        session.startTime = Date.now();

        // 创建调试函数
        const debugFunction = this.createDebuggableFunction(code, session);

        return {
            session: session,
            execute: async (...args) => {
                return await this.executeWithDebugging(debugFunction, session, ...args);
            },
            pause: () => this.pauseExecution(session),
            resume: () => this.resumeExecution(session),
            stepOver: () => this.stepOver(session),
            stepInto: () => this.stepInto(session),
            stepOut: () => this.stepOut(session)
        };
    }

    // 创建可调试函数
    createDebuggableFunction(code, session) {
        // 在代码中插入调试点
        const instrumentedCode = this.instrumentCode(code, session);

        try {
            return new Function('session', 'debugger', instrumentedCode);
        } catch (error) {
            console.error('创建可调试函数失败:', error);
            return () => { throw error; };
        }
    }

    // 插桩代码
    instrumentCode(code, session) {
        // 简化的代码插桩实现
        const lines = code.split('\n');
        const instrumentedLines = [];

        lines.forEach((line, index) => {
            const lineNumber = index + 1;
            instrumentedLines.push(line);

            // 检查是否有断点
            const breakpointId = `script:${lineNumber}`;
            if (this.breakpoints.has(breakpointId)) {
                const breakpoint = this.breakpoints.get(breakpointId);
                if (breakpoint.enabled) {
                    instrumentedLines.push(`// DEBUG: Breakpoint at line ${lineNumber}`);
                    instrumentedLines.push(`debugger;`);
                }
            }
        });

        return instrumentedLines.join('\n');
    }

    // 带调试执行
    async executeWithDebugging(debugFunction, session, ...args) {
        session.state = 'running';
        session.callStack = [];

        try {
            const result = await debugFunction(session, this.createDebuggerAPI(session));
            session.state = 'completed';
            return result;
        } catch (error) {
            session.state = 'error';
            session.lastError = error;
            this.logToSession(session, `执行错误: ${error.message}`, 'error');
            throw error;
        }
    }

    // 创建调试器 API
    createDebuggerAPI(session) {
        return {
            log: (message, level = 'info') => {
                this.logToSession(session, message, level);
            },

            breakpoint: (lineNumber) => {
                const breakpointId = `script:${lineNumber}`;
                if (this.breakpoints.has(breakpointId)) {
                    const breakpoint = this.breakpoints.get(breakpointId);
                    breakpoint.hitCount++;
                    this.logToSession(session, `断点命中: ${breakpointId}`, 'debug');
                    return true;
                }
                return false;
            },

            watch: (expression) => {
                const result = this.evaluateExpression(expression, session.variables);
                this.logToSession(session, `监视表达式 ${expression}: ${JSON.stringify(result)}`, 'debug');
                return result;
            },

            step: () => {
                this.logToSession(session, '单步执行', 'debug');
            }
        };
    }

    // 暂停执行
    pauseExecution(session) {
        if (session.state === 'running') {
            session.state = 'paused';
            this.logToSession(session, '执行已暂停', 'info');
        }
    }

    // 恢复执行
    resumeExecution(session) {
        if (session.state === 'paused') {
            session.state = 'running';
            this.logToSession(session, '执行已恢复', 'info');
        }
    }

    // 单步跳过
    stepOver(session) {
        if (session.state === 'paused') {
            this.logToSession(session, '单步跳过', 'debug');
            session.state = 'stepping';
        }
    }

    // 单步进入
    stepInto(session) {
        if (session.state === 'paused') {
            this.logToSession(session, '单步进入', 'debug');
            session.state = 'stepping';
        }
    }

    // 单步跳出
    stepOut(session) {
        if (session.state === 'paused') {
            this.logToSession(session, '单步跳出', 'debug');
            session.state = 'stepping';
        }
    }

    // 记录到会话
    logToSession(session, message, level = 'info') {
        const logEntry = {
            timestamp: Date.now(),
            level: level,
            message: message,
            callStack: [...session.callStack]
        };

        session.logs.push(logEntry);

        // 限制日志数量
        if (session.logs.length > 1000) {
            session.logs = session.logs.slice(-500);
        }
    }

    // 获取会话日志
    getSessionLogs(sessionName, level = null) {
        const session = this.debugSessions.get(sessionName);
        if (!session) return [];

        const logs = session.logs;
        if (level) {
            return logs.filter(log => log.level === level);
        }
        return logs;
    }

    // 调试统计
    getDebugStats() {
        return {
            totalSessions: this.debugSessions.size,
            activeSessions: Array.from(this.debugSessions.values())
                .filter(s => s.state !== 'completed').length,
            totalBreakpoints: this.breakpoints.size,
            enabledBreakpoints: Array.from(this.breakpoints.values())
                .filter(b => b.enabled).length,
            totalWatchExpressions: this.watchExpressions.size,
            totalLogs: Array.from(this.debugSessions.values())
                .reduce((sum, s) => sum + s.logs.length, 0)
        };
    }

    // 性能分析调试
    createPerformanceDebugger() {
        const performanceData = new Map();

        return {
            startMeasure: (name) => {
                performanceData.set(name, {
                    startTime: performance.now(),
                    measurements: [],
                    memory: this.getMemoryUsage()
                });
            },

            endMeasure: (name) => {
                const data = performanceData.get(name);
                if (data) {
                    data.endTime = performance.now();
                    data.duration = data.endTime - data.startTime;
                    data.memory = this.getMemoryUsage();
                }
                return data;
            },

            mark: (name) => {
                performanceData.set(`mark_${name}_${Date.now()}`, {
                    timestamp: performance.now(),
                    type: 'mark'
                });
            },

            measure: (name, startMark, endMark) => {
                const start = performanceData.get(startMark);
                const end = performanceData.get(endMark);

                if (start && end) {
                    const duration = end.timestamp - start.timestamp;
                    performanceData.set(name, {
                        startTime: start.timestamp,
                        endTime: end.timestamp,
                        duration: duration,
                        type: 'measure'
                    });
                }
            },

            getPerformanceData: () => {
                return Array.from(performanceData.entries());
            },

            clearPerformanceData: () => {
                performanceData.clear();
            }
        };
    }

    // 获取内存使用情况
    getMemoryUsage() {
        if (performance.memory) {
            return {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            };
        }
        return { used: 0, total: 0, limit: 0 };
    }

    // 调试报告生成器
    generateDebugReport(sessionName) {
        const session = this.debugSessions.get(sessionName);
        if (!session) return null;

        const report = {
            sessionName: sessionName,
            startTime: session.startTime,
            endTime: Date.now(),
            duration: Date.now() - session.startTime,
            state: session.state,
            breakpoints: session.breakpoints.size,
            watchExpressions: session.watchExpressions.size,
            logSummary: this.generateLogSummary(session.logs),
            performanceSummary: this.generatePerformanceSummary(session),
            recommendations: this.generateDebugRecommendations(session)
        };

        return report;
    }

    // 生成日志摘要
    generateLogSummary(logs) {
        const summary = {
            totalLogs: logs.length,
            byLevel: {},
            byTime: {
                firstHour: 0,
                lastHour: 0
            }
        };

        const oneHour = 60 * 60 * 1000;
        const now = Date.now();

        logs.forEach(log => {
            // 按级别统计
            summary.byLevel[log.level] = (summary.byLevel[log.level] || 0) + 1;

            // 按时间统计
            const age = now - log.timestamp;
            if (age < oneHour) {
                summary.byTime.lastHour++;
            } else {
                summary.byTime.firstHour++;
            }
        });

        return summary;
    }

    // 生成性能摘要
    generatePerformanceSummary(session) {
        // 简化的性能摘要
        return {
            averageExecutionTime: 0,
            memoryUsage: this.getMemoryUsage(),
            bottleneckCount: 0
        };
    }

    // 生成调试建议
    generateDebugRecommendations(session) {
        const recommendations = [];

        // 分析日志
        const errorLogs = session.logs.filter(log => log.level === 'error');
        if (errorLogs.length > 0) {
            recommendations.push({
                type: 'errors',
                message: `发现 ${errorLogs.length} 个错误，建议重点关注`,
                count: errorLogs.length
            });
        }

        // 分析执行时间
        const duration = Date.now() - session.startTime;
        if (duration > 10000) { // 10秒
            recommendations.push({
                type: 'performance',
                message: '执行时间较长，建议优化性能',
                duration: duration
            });
        }

        return recommendations;
    }
}

// 使用示例
const debugger = new AdvancedDebugger();

// 设置断点
debugger.setBreakpoint('script.js', 10, 'x > 100');

// 添加监视表达式
const watch1 = debugger.addWatchExpression('user.name');
const watch2 = debugger.addWatchExpression('items.length');

// 创建调试会话
const session = debugger.createDebugSession('test-session');

// 测试代码
const testCode = `
    function calculateSum(arr) {
        let sum = 0;
        for (let i = 0; i < arr.length; i++) {
            sum += arr[i];
            session.log(\`处理第 \${i} 个元素\`);
        }
        return sum;
    }

    return calculateSum([1, 2, 3, 4, 5]);
`;

// 开始调试
const debugContext = debugger.startDebugging('test-session', testCode);

// 执行调试
debugContext.execute().then(result => {
    console.log('调试结果:', result);

    // 生成调试报告
    const report = debugger.generateDebugReport('test-session');
    console.log('调试报告:', report);
});

console.log('调试统计:', debugger.getDebugStats());
```

## 总结

JavaScript 性能优化与调试是构建高质量应用的关键：

1. **性能分析**：全面的性能指标体系和基准测试
2. **性能分析工具**：深度性能分析和瓶颈识别
3. **算法优化**：复杂度分析和算法选择
4. **内存优化**：对象池、弱引用、内存映射等技术
5. **调试技术**：高级调试器和问题诊断

通过掌握这些技术，你可以构建高性能、稳定可靠的 JavaScript 应用程序，并为用户提供更好的体验。

下一篇博客将探讨 JavaScript 的元编程与 Proxy 应用。