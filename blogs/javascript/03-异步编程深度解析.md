# JavaScript 异步编程深度解析

JavaScript 是单线程语言，但通过异步编程可以处理并发操作。本文将深入探讨 JavaScript 中的异步编程机制，从回调函数到现代的 async/await。

## 同步与异步

### 同步编程

```javascript
console.log("开始");

// 同步代码会阻塞执行
function syncTask() {
    const start = Date.now();
    while (Date.now() - start < 2000) {
        // 模拟耗时操作
    }
    console.log("同步任务完成");
}

syncTask();
console.log("结束");

// 输出：
// 开始
// (等待2秒)
// 同步任务完成
// 结束
```

### 异步编程

```javascript
console.log("开始");

// 异步代码不会阻塞执行
setTimeout(() => {
    console.log("异步任务完成");
}, 2000);

console.log("结束");

// 输出：
// 开始
// 结束
// (2秒后)
// 异步任务完成
```

## 事件循环（Event Loop）

JavaScript 的并发模型基于事件循环，理解事件循环对于掌握异步编程至关重要。

```javascript
console.log("1");

setTimeout(() => {
    console.log("2");
}, 0);

Promise.resolve().then(() => {
    console.log("3");
});

console.log("4");

// 输出顺序：1 -> 4 -> 3 -> 2
// 解释：
// 1. 同步代码立即执行：1, 4
// 2. 微任务（Promise）优先于宏任务（setTimeout）：3 -> 2
```

### 事件循环的执行顺序

```javascript
console.log("Start");

// 同步代码
console.log("Sync 1");

// 微任务队列
Promise.resolve().then(() => console.log("Promise 1"));

// 宏任务队列
setTimeout(() => {
    console.log("Timeout 1");
    Promise.resolve().then(() => console.log("Promise 2"));
}, 0);

// 同步代码
console.log("Sync 2");

// 微任务队列
Promise.resolve().then(() => console.log("Promise 3"));

// 输出：
// Start
// Sync 1
// Sync 2
// Promise 1
// Promise 3
// Timeout 1
// Promise 2
```

## 回调函数（Callback）

### 基本回调

```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = { id: 1, name: "用户数据" };
        callback(null, data); // 第一个参数是错误，第二个是结果
    }, 1000);
}

fetchData((error, data) => {
    if (error) {
        console.error("错误:", error);
        return;
    }
    console.log("数据:", data);
});
```

### 回调地狱（Callback Hell）

```javascript
// 嵌套回调导致的回调地狱
getUser((user) => {
    getPosts(user.id, (posts) => {
        getComments(posts[0].id, (comments) => {
            getAuthor(comments[0].authorId, (author) => {
                console.log("最终结果:", author);
            });
        });
    });
});
```

## Promise

### Promise 基础

```javascript
// 创建 Promise
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        const success = Math.random() > 0.5;
        if (success) {
            resolve("操作成功");
        } else {
            reject("操作失败");
        }
    }, 1000);
});

// 使用 Promise
promise
    .then(result => console.log("成功:", result))
    .catch(error => console.error("失败:", error))
    .finally(() => console.log("无论如何都会执行"));
```

### Promise 链式调用

```javascript
function fetchUser(id) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({ id, name: `用户${id}` });
        }, 500);
    });
}

function fetchPosts(userId) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve([
                { id: 1, userId, title: "文章1" },
                { id: 2, userId, title: "文章2" }
            ]);
        }, 500);
    });
}

// 链式调用避免了回调地狱
fetchUser(1)
    .then(user => {
        console.log("用户:", user);
        return fetchPosts(user.id);
    })
    .then(posts => {
        console.log("文章:", posts);
        return posts.length;
    })
    .then(count => {
        console.log("文章数量:", count);
    })
    .catch(error => {
        console.error("错误:", error);
    });
```

### Promise 静态方法

```javascript
// Promise.all - 所有 Promise 都成功
const promises = [
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.resolve(3)
];

Promise.all(promises)
    .then(results => console.log("全部成功:", results))
    .catch(error => console.error("有错误:", error));

// Promise.allSettled - 等待所有 Promise 完成
const mixedPromises = [
    Promise.resolve(1),
    Promise.reject("错误"),
    Promise.resolve(3)
];

Promise.allSettled(mixedPromises)
    .then(results => {
        results.forEach(result => {
            if (result.status === 'fulfilled') {
                console.log("成功:", result.value);
            } else {
                console.log("失败:", result.reason);
            }
        });
    });

// Promise.race - 第一个完成的 Promise
const racePromises = [
    new Promise(resolve => setTimeout(() => resolve("快"), 100)),
    new Promise(resolve => setTimeout(() => resolve("慢"), 200))
];

Promise.race(racePromises)
    .then(result => console.log("Race 结果:", result));

// Promise.any - 任何一个成功的 Promise
const anyPromises = [
    Promise.reject("错误1"),
    Promise.reject("错误2"),
    Promise.resolve("成功")
];

Promise.any(anyPromises)
    .then(result => console.log("Any 结果:", result))
    .catch(error => console.error("全部失败:", error));
```

## Async/Await

### 基本语法

```javascript
// async 函数总是返回 Promise
async function hello() {
    return "Hello World";
}

// 等同于
function hello() {
    return Promise.resolve("Hello World");
}

// 使用 await
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("获取数据失败:", error);
        throw error;
    }
}
```

### 实际应用

```javascript
// 模拟异步操作
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// 使用 async/await 重写回调地狱
async function getCompleteData() {
    try {
        const user = await fetchUser(1);
        console.log("用户:", user);

        const posts = await fetchPosts(user.id);
        console.log("文章:", posts);

        const comments = await fetchComments(posts[0].id);
        console.log("评论:", comments);

        return { user, posts, comments };
    } catch (error) {
        console.error("获取完整数据失败:", error);
        throw error;
    }
}

// 并行执行
async function parallelExecution() {
    try {
        // 并行执行多个异步操作
        const [users, posts, comments] = await Promise.all([
            fetchUsers(),
            fetchPosts(),
            fetchComments()
        ]);

        return { users, posts, comments };
    } catch (error) {
        console.error("并行执行失败:", error);
        throw error;
    }
}
```

### 错误处理

```javascript
// 错误处理的最佳实践
async function robustDataFetch() {
    try {
        // 设置超时
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("请求超时")), 5000);
        });

        const dataPromise = fetch('https://api.example.com/data');

        const response = await Promise.race([dataPromise, timeoutPromise]);

        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status}`);
        }

        const data = await response.json();
        return data;

    } catch (error) {
        if (error instanceof TypeError) {
            console.error("网络错误:", error);
        } else if (error.message === "请求超时") {
            console.error("请求超时:", error);
        } else {
            console.error("其他错误:", error);
        }

        // 返回默认值或重新抛出错误
        return { error: true, message: error.message };
    }
}
```

## 实际应用场景

### 数据获取和缓存

```javascript
class DataManager {
    constructor() {
        this.cache = new Map();
    }

    async getData(key, fetchFunction) {
        // 检查缓存
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }

        try {
            // 防止重复请求
            if (this.pendingRequests.has(key)) {
                return await this.pendingRequests.get(key);
            }

            const promise = fetchFunction();
            this.pendingRequests.set(key, promise);

            const data = await promise;

            // 缓存结果
            this.cache.set(key, data);
            this.pendingRequests.delete(key);

            return data;
        } catch (error) {
            this.pendingRequests.delete(key);
            throw error;
        }
    }

    clearCache() {
        this.cache.clear();
        this.pendingRequests.clear();
    }
}

// 使用示例
const dataManager = new DataManager();

async function getUserWithCache(userId) {
    return dataManager.getData(
        `user_${userId}`,
        () => fetchUser(userId)
    );
}
```

### 批量处理

```javascript
class BatchProcessor {
    constructor(batchSize = 5, delay = 100) {
        this.batchSize = batchSize;
        this.delay = delay;
        this.queue = [];
        this.processing = false;
    }

    async add(task) {
        return new Promise((resolve, reject) => {
            this.queue.push({ task, resolve, reject });
            this.process();
        });
    }

    async process() {
        if (this.processing) return;

        this.processing = true;

        while (this.queue.length > 0) {
            const batch = this.queue.splice(0, this.batchSize);

            try {
                const results = await Promise.all(
                    batch.map(item => item.task())
                );

                results.forEach((result, index) => {
                    batch[index].resolve(result);
                });
            } catch (error) {
                batch.forEach(item => item.reject(error));
            }

            if (this.queue.length > 0) {
                await new Promise(resolve => setTimeout(resolve, this.delay));
            }
        }

        this.processing = false;
    }
}

// 使用示例
const processor = new BatchProcessor();

async function processItems(items) {
    const promises = items.map(item =>
        processor.add(() => processItem(item))
    );

    return Promise.all(promises);
}
```

### 请求重试机制

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3, delay = 1000) {
    let lastError;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const response = await fetch(url, options);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            lastError = error;

            if (attempt === maxRetries) {
                break;
            }

            // 指数退避
            const waitTime = delay * Math.pow(2, attempt - 1);
            console.log(`第 ${attempt} 次失败，${waitTime}ms 后重试`);

            await new Promise(resolve => setTimeout(resolve, waitTime));
        }
    }

    throw lastError;
}
```

## 性能优化

### 节流和防抖的异步版本

```javascript
// 异步节流
function asyncThrottle(func, delay) {
    let lastCall = 0;
    let pendingPromise = null;

    return async function(...args) {
        const now = Date.now();

        if (pendingPromise) {
            return pendingPromise;
        }

        if (now - lastCall >= delay) {
            lastCall = now;
            return func.apply(this, args);
        }

        const timeToWait = delay - (now - lastCall);

        pendingPromise = new Promise(async (resolve) => {
            setTimeout(async () => {
                try {
                    const result = await func.apply(this, args);
                    resolve(result);
                } finally {
                    pendingPromise = null;
                    lastCall = Date.now();
                }
            }, timeToWait);
        });

        return pendingPromise;
    };
}

// 异步防抖
function asyncDebounce(func, delay) {
    let timeoutId = null;
    let pendingPromise = null;

    return async function(...args) {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }

        if (pendingPromise) {
            return pendingPromise;
        }

        pendingPromise = new Promise((resolve, reject) => {
            timeoutId = setTimeout(async () => {
                try {
                    const result = await func.apply(this, args);
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    pendingPromise = null;
                    timeoutId = null;
                }
            }, delay);
        });

        return pendingPromise;
    };
}
```

### 并发控制

```javascript
class ConcurrencyLimiter {
    constructor(maxConcurrent) {
        this.maxConcurrent = maxConcurrent;
        this.current = 0;
        this.queue = [];
    }

    async execute(task) {
        if (this.current >= this.maxConcurrent) {
            await new Promise(resolve => this.queue.push(resolve));
        }

        this.current++;

        try {
            return await task();
        } finally {
            this.current--;

            if (this.queue.length > 0) {
                const next = this.queue.shift();
                next();
            }
        }
    }
}

// 使用示例
const limiter = new ConcurrencyLimiter(3);

async function processManyItems(items) {
    const promises = items.map(item =>
        limiter.execute(() => processItem(item))
    );

    return Promise.all(promises);
}
```

## 调试异步代码

### 异步代码的调试技巧

```javascript
// 添加调试信息
async function debugFetch(url) {
    console.log(`开始请求: ${url}`);
    const startTime = Date.now();

    try {
        const response = await fetch(url);
        const endTime = Date.now();
        console.log(`请求完成: ${url}, 耗时: ${endTime - startTime}ms`);

        if (!response.ok) {
            console.error(`HTTP错误: ${response.status}`);
        }

        return response;
    } catch (error) {
        const endTime = Date.now();
        console.error(`请求失败: ${url}, 耗时: ${endTime - startTime}ms, 错误:`, error);
        throw error;
    }
}

// 使用 async/await 时捕获完整的错误堆栈
async function safeAsyncOperation() {
    try {
        const result = await someAsyncOperation();
        return result;
    } catch (error) {
        console.error('异步操作失败:', {
            error: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        });
        throw error;
    }
}
```

## 总结

JavaScript 异步编程是现代 Web 开发的核心技能，本文深入探讨了：

- 事件循环机制和执行顺序
- 回调函数及其问题（回调地狱）
- Promise 及其链式调用
- Async/Await 的使用和最佳实践
- 错误处理和异常管理
- 实际应用场景（缓存、批量处理、重试机制）
- 性能优化（节流、防抖、并发控制）
- 异步代码的调试技巧

掌握这些概念将帮助你构建高性能、可维护的异步应用程序。下一篇博客将介绍 JavaScript 的原型链与面向对象编程。