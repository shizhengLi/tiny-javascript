# JavaScript 原型链与面向对象编程

JavaScript 是一种基于原型的面向对象编程语言，与传统的基于类的面向对象语言有所不同。本文将深入探讨 JavaScript 中的原型链机制和面向对象编程的实现方式。

## 理解原型

### 什么是原型

在 JavaScript 中，每个对象都有一个原型（prototype），原型也是一个对象。当我们试图访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript 会沿着原型链向上查找。

```javascript
// 创建一个对象
const person = {
    name: "张三",
    age: 25
};

// 查看对象的原型
console.log(Object.getPrototypeOf(person)); // {}

// person 对象继承了 Object.prototype 的方法
console.log(person.toString()); // [object Object]
console.log(person.hasOwnProperty('name')); // true
```

### 原型链的工作原理

```javascript
// 创建一个原型链
const grandparent = {
    greet: function() {
        return "你好，我是祖先";
    }
};

const parent = Object.create(grandparent);
parent.age = 50;

const child = Object.create(parent);
child.name = "小明";
child.age = 10;

// 测试原型链
console.log(child.name); // 小明 (自身属性)
console.log(child.age); // 10 (自身属性，覆盖了 parent 的 age)
console.log(child.greet()); // 你好，我是祖先 (从 grandparent 继承)

// 检查原型链
console.log(child.hasOwnProperty('name')); // true
console.log(child.hasOwnProperty('age')); // true
console.log(child.hasOwnProperty('greet')); // false

console.log(Object.getPrototypeOf(child) === parent); // true
console.log(Object.getPrototypeOf(parent) === grandparent); // true
```

## 构造函数

### 基本构造函数

```javascript
// 构造函数通常以大写字母开头
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// 在原型上添加方法
Person.prototype.greet = function() {
    return `你好，我是${this.name}，今年${this.age}岁`;
};

Person.prototype.celebrateBirthday = function() {
    this.age++;
    return `我今年${this.age}岁了！`;
};

// 创建实例
const person1 = new Person("张三", 25);
const person2 = new Person("李四", 30);

console.log(person1.greet()); // 你好，我是张三，今年25岁
console.log(person2.greet()); // 你好，我是李四，今年30岁

console.log(person1.celebrateBirthday()); // 我今年26岁了！
console.log(person1.age); // 26

// 检查实例
console.log(person1 instanceof Person); // true
console.log(person1.constructor === Person); // true
```

### 构造函数的内部机制

```javascript
function User(name) {
    // 1. 创建新对象 (this = {})
    // 2. 设置原型链 (this.__proto__ = User.prototype)
    // 3. 绑定 this 到新对象
    // 4. 执行构造函数代码
    // 5. 返回新对象

    this.name = name;
}

// 手动模拟 new 操作符
function myNew(constructor, ...args) {
    const obj = Object.create(constructor.prototype);
    const result = constructor.apply(obj, args);

    return result instanceof Object ? result : obj;
}

// 使用自定义 new
const user = myNew(User, "王五");
console.log(user.name); // 王五
console.log(user instanceof User); // true
```

## 原型继承

### 经典继承模式

```javascript
// 父构造函数
function Animal(name) {
    this.name = name;
}

Animal.prototype.eat = function() {
    return `${this.name}正在吃东西`;
};

Animal.prototype.sleep = function() {
    return `${this.name}正在睡觉`;
};

// 子构造函数
function Dog(name, breed) {
    Animal.call(this, name); // 调用父构造函数
    this.breed = breed;
}

// 设置原型链
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // 修复 constructor

// 添加子类特有方法
Dog.prototype.bark = function() {
    return `${this.name}在汪汪叫`;
};

// 重写父类方法
Dog.prototype.eat = function() {
    return `${this.name}正在吃狗粮`;
};

// 创建实例
const dog = new Dog("旺财", "金毛");

console.log(dog.name); // 旺财
console.log(dog.breed); // 金毛
console.log(dog.eat()); // 旺财正在吃狗粮
console.log(dog.sleep()); // 旺财正在睡觉
console.log(dog.bark()); // 旺财在汪汪叫

console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true
```

### 原型继承的几种方式

```javascript
// 1. 原型链继承
function Parent() {
    this.parentProperty = "父类属性";
}

Parent.prototype.parentMethod = function() {
    return "父类方法";
};

function Child() {
    this.childProperty = "子类属性";
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child1 = new Child();
console.log(child1.parentProperty); // 父类属性
console.log(child1.parentMethod()); // 父类方法

// 2. 构造函数继承
function Parent2(name) {
    this.name = name;
}

function Child2(name, age) {
    Parent2.call(this, name);
    this.age = age;
}

const child2 = new Child2("张三", 25);
console.log(child2.name); // 张三
console.log(child2.age); // 25

// 3. 组合继承
function Parent3(name) {
    this.name = name;
}

Parent3.prototype.sayHello = function() {
    return `你好，我是${this.name}`;
};

function Child3(name, age) {
    Parent3.call(this, name);
    this.age = age;
}

Child3.prototype = Object.create(Parent3.prototype);
Child3.prototype.constructor = Child3;

const child3 = new Child3("李四", 30);
console.log(child3.sayHello()); // 你好，我是李四
console.log(child3.age); // 30
```

## ES6 类语法

### 基本类定义

```javascript
class Person {
    // 构造函数
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    // 实例方法
    greet() {
        return `你好，我是${this.name}`;
    }

    // 静态方法
    static createAdult(name) {
        return new Person(name, 18);
    }

    // getter
    get info() {
        return `${this.name}, ${this.age}岁`;
    }

    // setter
    set age(newAge) {
        if (newAge < 0) {
            throw new Error("年龄不能为负数");
        }
        this._age = newAge;
    }

    get age() {
        return this._age;
    }
}

// 使用类
const person = new Person("王五", 25);
console.log(person.greet()); // 你好，我是王五
console.log(person.info); // 王五, 25岁

const adult = Person.createAdult("成年人");
console.log(adult.age); // 18
```

### 类的继承

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    eat() {
        return `${this.name}正在吃东西`;
    }

    static getSpecies() {
        return "动物";
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // 调用父类构造函数
        this.breed = breed;
    }

    bark() {
        return `${this.name}在汪汪叫`;
    }

    eat() {
        // 调用父类方法
        const parentResult = super.eat();
        return `${parentResult} (吃狗粮)`;
    }

    static getSpecies() {
        return "狗";
    }
}

// 使用继承
const dog = new Dog("旺财", "金毛");
console.log(dog.eat()); // 旺财正在吃东西 (吃狗粮)
console.log(dog.bark()); // 旺财在汪汪叫

console.log(Animal.getSpecies()); // 动物
console.log(Dog.getSpecies()); // 狗
```

### 类的高级特性

```javascript
class Calculator {
    // 私有字段 (ES2022)
    #history = [];
    #precision = 2;

    constructor() {
        this.result = 0;
    }

    // 公共方法
    add(number) {
        this.#history.push(`+${number}`);
        this.result += number;
        return this;
    }

    subtract(number) {
        this.#history.push(`-${number}`);
        this.result -= number;
        return this;
    }

    multiply(number) {
        this.#history.push(`*${number}`);
        this.result *= number;
        return this;
    }

    divide(number) {
        if (number === 0) {
            throw new Error("除数不能为零");
        }
        this.#history.push(`/${number}`);
        this.result /= number;
        return this;
    }

    // 方法链式调用
    calculate() {
        return Number(this.result.toFixed(this.#precision));
    }

    // 私有方法
    #formatHistory() {
        return this.#history.join(' ');
    }

    getHistory() {
        return this.#formatHistory();
    }

    // 静私有字段
    static #version = '1.0.0';

    static getVersion() {
        return this.#version;
    }
}

// 使用链式调用
const result = new Calculator()
    .add(10)
    .multiply(2)
    .subtract(5)
    .divide(3)
    .calculate();

console.log(result); // 5
console.log(Calculator.getVersion()); // 1.0.0
```

## 设计模式

### 单例模式

```javascript
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }
        Singleton.instance = this;
        this.data = [];
    }

    addData(item) {
        this.data.push(item);
    }

    getData() {
        return [...this.data];
    }

    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}

// 使用单例
const singleton1 = Singleton.getInstance();
const singleton2 = Singleton.getInstance();

console.log(singleton1 === singleton2); // true

singleton1.addData("数据1");
console.log(singleton2.getData()); // ["数据1"]
```

### 工厂模式

```javascript
class ShapeFactory {
    static createShape(type, ...params) {
        switch (type) {
            case 'circle':
                return new Circle(...params);
            case 'rectangle':
                return new Rectangle(...params);
            case 'triangle':
                return new Triangle(...params);
            default:
                throw new Error(`未知的形状类型: ${type}`);
        }
    }
}

class Circle {
    constructor(radius) {
        this.radius = radius;
        this.type = 'circle';
    }

    getArea() {
        return Math.PI * this.radius * this.radius;
    }
}

class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.type = 'rectangle';
    }

    getArea() {
        return this.width * this.height;
    }
}

class Triangle {
    constructor(base, height) {
        this.base = base;
        this.height = height;
        this.type = 'triangle';
    }

    getArea() {
        return 0.5 * this.base * this.height;
    }
}

// 使用工厂
const circle = ShapeFactory.createShape('circle', 5);
const rectangle = ShapeFactory.createShape('rectangle', 4, 6);
const triangle = ShapeFactory.createShape('triangle', 3, 4);

console.log(circle.getArea()); // 78.53981633974483
console.log(rectangle.getArea()); // 24
console.log(triangle.getArea()); // 6
```

### 观察者模式

```javascript
class Observable {
    constructor() {
        this.observers = [];
    }

    subscribe(observer) {
        this.observers.push(observer);
        return () => {
            this.observers = this.observers.filter(obs => obs !== observer);
        };
    }

    notify(data) {
        this.observers.forEach(observer => {
            observer.update(data);
        });
    }
}

class Observer {
    constructor(name) {
        this.name = name;
    }

    update(data) {
        console.log(`${this.name} 收到更新: ${data}`);
    }
}

// 使用观察者模式
const observable = new Observable();

const observer1 = new Observer("观察者1");
const observer2 = new Observer("观察者2");

const unsubscribe1 = observable.subscribe(observer1);
const unsubscribe2 = observable.subscribe(observer2);

observable.notify("数据更新了！");
// 观察者1 收到更新: 数据更新了！
// 观察者2 收到更新: 数据更新了！

unsubscribe1();
observable.notify("又一次更新");
// 观察者2 收到更新: 又一次更新
```

## 混入（Mixin）

### 简单混入

```javascript
// 可混入的功能模块
const canEat = {
    eat() {
        return `${this.name}正在吃东西`;
    }
};

const canSleep = {
    sleep() {
        return `${this.name}正在睡觉`;
    }
};

const canPlay = {
    play() {
        return `${this.name}正在玩耍`;
    }
};

// 混入函数
function mixin(target, ...sources) {
    sources.forEach(source => {
        Object.getOwnPropertyNames(source).forEach(prop => {
            if (prop !== 'constructor') {
                target.prototype[prop] = source[prop];
            }
        });
    });
}

// 创建类
class Person {
    constructor(name) {
        this.name = name;
    }
}

// 混入功能
mixin(Person, canEat, canSleep, canPlay);

const person = new Person("小明");
console.log(person.eat()); // 小明正在吃东西
console.log(person.sleep()); // 小明正在睡觉
console.log(person.play()); // 小明正在玩耍
```

### 复杂混入

```javascript
// 事件混入
const EventMixin = {
    on(event, callback) {
        if (!this._events) this._events = {};
        if (!this._events[event]) this._events[event] = [];
        this._events[event].push(callback);
    },

    off(event, callback) {
        if (!this._events) return;
        if (!this._events[event]) return;
        this._events[event] = this._events[event].filter(cb => cb !== callback);
    },

    emit(event, ...args) {
        if (!this._events) return;
        if (!this._events[event]) return;
        this._events[event].forEach(callback => callback(...args));
    }
};

// 日志混入
const LogMixin = {
    log(message) {
        console.log(`[${this.constructor.name}] ${message}`);
    }
};

// 使用混入
class UserManager {
    constructor() {
        this.users = [];
    }

    addUser(user) {
        this.users.push(user);
        this.log(`添加用户: ${user}`);
        this.emit('userAdded', user);
    }

    removeUser(user) {
        const index = this.users.indexOf(user);
        if (index > -1) {
            this.users.splice(index, 1);
            this.log(`移除用户: ${user}`);
            this.emit('userRemoved', user);
        }
    }
}

// 应用混入
Object.assign(UserManager.prototype, EventMixin, LogMixin);

// 使用
const userManager = new UserManager();
userManager.on('userAdded', (user) => {
    console.log(`监听到用户添加: ${user}`);
});

userManager.addUser("张三");
// [UserManager] 添加用户: 张三
// 监听到用户添加: 张三
```

## 性能优化和最佳实践

### 原型链优化

```javascript
// 避免在原型上定义过多属性
class OptimizedPerson {
    constructor(name, age) {
        this.name = name;
        this.age = age;
        // 将不会改变的属性定义在构造函数中
        this._cache = new Map();
    }

    // 将方法定义在原型上
    getName() {
        return this.name;
    }

    // 使用 getter 和 setter
    get age() {
        return this._age;
    }

    set age(value) {
        if (value < 0) {
            throw new Error("年龄不能为负数");
        }
        this._age = value;
    }
}

// 避免深层次继承链
class GrandParent {
    constructor() {
        this.grandProp = "祖父属性";
    }
}

class Parent extends GrandParent {
    constructor() {
        super();
        this.parentProp = "父属性";
    }
}

class Child extends Parent {
    constructor() {
        super();
        this.childProp = "子属性";
    }
}

// 考虑使用组合替代继承
class Engine {
    start() {
        return "引擎启动";
    }
}

class Car {
    constructor() {
        this.engine = new Engine();
    }

    start() {
        return this.engine.start();
    }
}
```

### 内存管理

```javascript
// 避免循环引用
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }

    // 手动清理引用
    destroy() {
        if (this.next) {
            this.next.prev = null;
        }
        if (this.prev) {
            this.prev.next = null;
        }
        this.next = null;
        this.prev = null;
    }
}

// 使用 WeakMap 避免内存泄漏
const privateData = new WeakMap();

class PrivateClass {
    constructor(data) {
        privateData.set(this, { data, created: Date.now() });
    }

    getData() {
        return privateData.get(this).data;
    }
}

// 使用 Symbol 避免属性名冲突
const _private = Symbol('private');

class SymbolClass {
    constructor() {
        this[_private] = "私有数据";
    }

    getPrivate() {
        return this[_private];
    }
}
```

## 总结

JavaScript 的原型链和面向对象编程是其核心特性之一。本文深入探讨了：

- 原型和原型链的工作原理
- 构造函数和 new 操作符的内部机制
- 原型继承的几种实现方式
- ES6 类语法和继承
- 设计模式的应用（单例、工厂、观察者）
- 混入（Mixin）模式的实现
- 性能优化和内存管理的最佳实践

理解这些概念将帮助你构建更加模块化、可维护的 JavaScript 应用程序。下一篇博客将介绍 JavaScript 中的闭包与高阶函数的深度应用。