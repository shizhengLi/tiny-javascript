# JavaScript 函数与作用域

函数是 JavaScript 中的一等公民，而作用域是理解 JavaScript 工作原理的核心概念。本文将深入探讨 JavaScript 中的函数和作用域机制。

## 函数的定义方式

### 1. 函数声明

```javascript
// 函数声明 - 具有函数提升特性
function add(a, b) {
    return a + b;
}

// 可以在声明之前调用
console.log(sum(5, 3)); // 8
function sum(x, y) {
    return x + y;
}
```

### 2. 函数表达式

```javascript
// 函数表达式 - 不具有函数提升
const multiply = function(a, b) {
    return a * b;
};

// 匿名函数
const divide = function(a, b) {
    return a / b;
};

// 命名函数表达式
const factorial = function fact(n) {
    if (n <= 1) return 1;
    return n * fact(n - 1);
};
```

### 3. 箭头函数（ES6）

```javascript
// 基本箭头函数
const add = (a, b) => a + b;

// 带多个参数
const multiply = (a, b, c) => a * b * c;

// 带函数体
const calculate = (a, b) => {
    const sum = a + b;
    const product = a * b;
    return { sum, product };
};

// 单个参数可以省略括号
const square = x => x * x;

// 无参数需要空括号
const getRandom = () => Math.random();

// 箭头函数的特殊性
const obj = {
    value: 42,
    regularFunction: function() {
        console.log(this.value); // 42
    },
    arrowFunction: () => {
        console.log(this.value); // undefined (this指向全局对象)
    }
};
```

## 函数参数

### 默认参数

```javascript
// ES6 默认参数
function greet(name = "访客", age = 18) {
    return `你好，${name}！你今年${age}岁。`;
}

console.log(greet()); // 你好，访客！你今年18岁。
console.log(greet("张三")); // 你好，张三！你今年18岁。
console.log(greet("李四", 25)); // 你好，李四！你今年25岁。

// 复杂默认值
function createUser(options = {}) {
    const defaultOptions = {
        name: "匿名用户",
        age: 0,
        isActive: true,
        role: "user"
    };

    return { ...defaultOptions, ...options };
}
```

### 剩余参数

```javascript
// 收集剩余参数
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4, 5)); // 15

// 与其他参数结合
function userInfo(name, ...hobbies) {
    return {
        name: name,
        hobbies: hobbies
    };
}
```

### 解构参数

```javascript
// 对象解构
function displayUser({ name, age, city = "北京" }) {
    return `${name}今年${age}岁，住在${city}`;
}

const user = { name: "王五", age: 30, city: "上海" };
console.log(displayUser(user)); // 王五今年30岁，住在上海

// 数组解构
function getFirstAndSecond([first, second]) {
    return [first, second];
}

const numbers = [10, 20, 30];
console.log(getFirstAndSecond(numbers)); // [10, 20]
```

## 作用域

### 全局作用域

```javascript
// 全局变量
let globalVar = "我是全局变量";

function showGlobal() {
    console.log(globalVar); // 可以访问
}

showGlobal(); // 我是全局变量
console.log(globalVar); // 我是全局变量

// 在浏览器中，全局对象是 window
window.globalVar = "通过window对象设置";
```

### 函数作用域

```javascript
function outer() {
    let functionVar = "我是函数作用域变量";

    function inner() {
        console.log(functionVar); // 可以访问
    }

    inner(); // 我是函数作用域变量
    console.log(functionVar); // 我是函数作用域变量
}

outer();
// console.log(functionVar); // ReferenceError: functionVar is not defined
```

### 块级作用域（ES6）

```javascript
// let 和 const 具有块级作用域
function blockScope() {
    let blockVar = "我是块级变量";
    const blockConst = "我是块级常量";

    if (true) {
        let ifVar = "我是if块中的变量";
        const ifConst = "我是if块中的常量";
        console.log(blockVar); // 可以访问
        console.log(ifVar); // 我是if块中的变量
    }

    console.log(blockVar); // 我是块级变量
    // console.log(ifVar); // ReferenceError: ifVar is not defined
}

blockScope();

// for 循环中的块级作用域
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i); // 0, 1, 2 (每个i都是独立的)
    }, 100);
}

// 对比使用 var
for (var j = 0; j < 3; j++) {
    setTimeout(() => {
        console.log(j); // 3, 3, 3 (j是同一个变量)
    }, 100);
}
```

## 作用域链

```javascript
// 作用域链示例
let globalVar = "全局";

function level1() {
    let level1Var = "第一层";

    function level2() {
        let level2Var = "第二层";

        function level3() {
            let level3Var = "第三层";

            // 可以访问所有外层作用域
            console.log(globalVar); // 全局
            console.log(level1Var); // 第一层
            console.log(level2Var); // 第二层
            console.log(level3Var); // 第三层
        }

        level3();
        // console.log(level3Var); // ReferenceError
    }

    level2();
    // console.log(level2Var); // ReferenceError
}

level1();
// console.log(level1Var); // ReferenceError
```

## 闭包

### 什么是闭包

闭包是指函数可以访问其外部作用域中变量的特性，即使外部函数已经执行完毕。

```javascript
// 基本闭包示例
function createCounter() {
    let count = 0;

    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
console.log(counter.getCount()); // 1

// count 变量被闭包保护，外部无法直接访问
```

### 实用的闭包应用

```javascript
// 1. 私有变量
function createBankAccount(initialBalance) {
    let balance = initialBalance;

    return {
        deposit: function(amount) {
            balance += amount;
            return balance;
        },
        withdraw: function(amount) {
            if (amount > balance) {
                throw new Error("余额不足");
            }
            balance -= amount;
            return balance;
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(1000);
console.log(account.deposit(500)); // 1500
console.log(account.withdraw(200)); // 1300
console.log(account.getBalance()); // 1300

// 2. 函数工厂
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double(5)); // 10
console.log(triple(5)); // 15
console.log(quadruple(5)); // 20

// 3. 事件处理器
function createClickHandler(message) {
    return function() {
        console.log(message);
    };
}

const button = document.createElement('button');
button.textContent = '点击我';
button.onclick = createClickHandler('按钮被点击了！');
document.body.appendChild(button);
```

## this 关键字

### this 的不同指向

```javascript
// 1. 全局作用域中的 this
console.log(this === window); // true (浏览器中)

// 2. 函数中的 this
function showThis() {
    console.log(this);
}

showThis(); // window (严格模式下是 undefined)

// 3. 方法中的 this
const obj = {
    name: "对象",
    showThis: function() {
        console.log(this === obj); // true
        console.log(this.name); // 对象
    }
};

obj.showThis();

// 4. 构造函数中的 this
function Person(name) {
    this.name = name;
}

const person = new Person("张三");
console.log(person.name); // 张三

// 5. 箭头函数中的 this
const arrowObj = {
    name: "箭头对象",
    regularMethod: function() {
        console.log(this.name); // 箭头对象
    },
    arrowMethod: () => {
        console.log(this.name); // undefined (继承外部作用域的this)
    }
};

arrowObj.regularMethod();
arrowObj.arrowMethod();
```

### 改变 this 指向

```javascript
// call() 方法
function greet(greeting, punctuation) {
    console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "张三" };

greet.call(person, "你好", "！"); // 你好，张三！

// apply() 方法
greet.apply(person, ["早上好", "。"]); // 早上好，张三。

// bind() 方法
const boundGreet = greet.bind(person);
boundGreet("晚上好", "~"); // 晚上好，张三~
```

## 函数的高级特性

### 高阶函数

```javascript
// 接受函数作为参数
function applyOperation(a, b, operation) {
    return operation(a, b);
}

const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

console.log(applyOperation(5, 3, add)); // 8
console.log(applyOperation(5, 3, multiply)); // 15

// 返回函数的函数
function createGreeter(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

const sayHello = createGreeter("Hello");
const sayGoodbye = createGreeter("Goodbye");

console.log(sayHello("Alice")); // Hello, Alice!
console.log(sayGoodbye("Bob")); // Goodbye, Bob!
```

### 纯函数

```javascript
// 纯函数：相同输入总是产生相同输出，没有副作用
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
const toUpperCase = str => str.toUpperCase();

// 非纯函数：有副作用或依赖外部状态
let counter = 0;
const increment = () => ++counter;
const getRandomNumber = () => Math.random();

// 纯函数的好处
// 1. 可测试性
// 2. 可缓存性
// 3. 可并行性
// 4. 可推导性
```

### 函数组合

```javascript
// 函数组合：将多个函数组合成一个新函数
const compose = (...functions) => (value) => {
    return functions.reduceRight((acc, fn) => fn(acc), value);
};

const pipe = (...functions) => (value) => {
    return functions.reduce((acc, fn) => fn(acc), value);
};

// 使用示例
const add5 = x => x + 5;
const multiply3 = x => x * 3;
const subtract2 = x => x - 2;

const composed = compose(subtract2, multiply3, add5);
const piped = pipe(add5, multiply3, subtract2);

console.log(composed(10)); // (10 + 5) * 3 - 2 = 43
console.log(piped(10)); // (10 + 5) * 3 - 2 = 43
```

## 内存管理和性能

### 内存泄漏的常见原因

```javascript
// 1. 意外的全局变量
function leakGlobal() {
    leakedVar = "我泄露了！"; // 没有使用 let/const/var
}

// 2. 闭包中的循环引用
function createLeak() {
    const bigData = new Array(1000000).fill('*');

    return function() {
        console.log(bigData.length);
        // 这个闭包保持对 bigData 的引用
    };
}

const leak = createLeak();

// 3. 定时器未清理
let count = 0;
const timer = setInterval(() => {
    count++;
    console.log(count);
}, 1000);

// 应该在不需要时清除定时器
// clearInterval(timer);
```

### 函数节流和防抖

```javascript
// 节流：限制函数执行频率
function throttle(func, delay) {
    let lastCall = 0;
    return function(...args) {
        const now = new Date().getTime();
        if (now - lastCall < delay) {
            return;
        }
        lastCall = now;
        return func.apply(this, args);
    };
}

// 防抖：延迟函数执行，只在停止触发后执行一次
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// 使用示例
const handleScroll = throttle(() => {
    console.log('滚动事件被节流处理');
}, 200);

const handleSearch = debounce((query) => {
    console.log('搜索:', query);
}, 300);
```

## 总结

本文深入探讨了 JavaScript 中的函数和作用域概念：

- 函数的定义方式（声明、表达式、箭头函数）
- 函数参数（默认参数、剩余参数、解构参数）
- 作用域类型（全局、函数、块级）
- 作用域链和闭包
- this 关键字的指向和改变方法
- 高阶函数和函数组合
- 纯函数的概念和好处
- 内存管理和性能优化

理解这些概念对于掌握 JavaScript 至关重要，它们是构建复杂应用程序的基础。下一篇博客将介绍 JavaScript 中的异步编程深度解析。