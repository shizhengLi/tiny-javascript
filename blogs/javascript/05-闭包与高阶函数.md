# JavaScript 闭包与高阶函数深度解析

闭包和高阶函数是 JavaScript 中最重要的概念之一，它们使得函数式编程在 JavaScript 中成为可能。本文将深入探讨闭包的机制、高阶函数的应用，以及它们在实际开发中的强大威力。

## 闭包详解

### 什么是闭包

闭包是指函数能够访问其外部作用域中变量的特性，即使外部函数已经执行完毕。简单来说，闭包就是函数加上其创建时所在的作用域。

```javascript
// 基本闭包示例
function createCounter() {
    let count = 0; // 这个变量被闭包"捕获"

    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
console.log(counter.getCount()); // 1

// count 变量被保护在闭包中，外部无法直接访问
// console.log(count); // ReferenceError: count is not defined
```

### 闭包的内存模型

```javascript
function outerFunction(x) {
    // 外部函数的作用域
    let outerVar = x;

    function innerFunction(y) {
        // 内部函数可以访问外部函数的变量
        let innerVar = y;
        return outerVar + innerVar;
    }

    return innerFunction;
}

const add5 = outerFunction(5);
console.log(add5(3)); // 8
console.log(add5(10)); // 15

// 即使 outerFunction 执行完毕，add5 仍然保持对 outerVar 的引用
```

### 闭包的生命周期

```javascript
function createLeakyClosure() {
    const largeData = new Array(1000000).fill('data');
    let counter = 0;

    return function() {
        counter++;
        if (counter > 5) {
            // 手动释放大对象引用
            largeData.length = 0;
            console.log('大对象已释放');
        }
        return counter;
    };
}

const leakyFunction = createLeakyClosure();
console.log(leakyFunction()); // 1
console.log(leakyFunction()); // 2
// ...
console.log(leakyFunction()); // 5
console.log(leakyFunction()); // 6 + "大对象已释放"
```

## 闭包的实际应用

### 1. 私有变量和方法

```javascript
class BankAccount {
    constructor(initialBalance) {
        let balance = initialBalance; // 私有变量

        // 私有方法
        function validateAmount(amount) {
            return typeof amount === 'number' && amount > 0;
        }

        // 公共接口
        this.deposit = function(amount) {
            if (validateAmount(amount)) {
                balance += amount;
                return true;
            }
            return false;
        };

        this.withdraw = function(amount) {
            if (validateAmount(amount) && amount <= balance) {
                balance -= amount;
                return true;
            }
            return false;
        };

        this.getBalance = function() {
            return balance;
        };
    }
}

const account = new BankAccount(1000);
console.log(account.getBalance()); // 1000
account.deposit(500);
console.log(account.getBalance()); // 1500
account.withdraw(200);
console.log(account.getBalance()); // 1300

// balance 变量无法直接访问
// console.log(account.balance); // undefined
```

### 2. 函数工厂

```javascript
// 创建不同数学运算的函数
function createMathOperation(operation) {
    switch (operation) {
        case 'add':
            return function(a, b) { return a + b; };
        case 'subtract':
            return function(a, b) { return a - b; };
        case 'multiply':
            return function(a, b) { return a * b; };
        case 'divide':
            return function(a, b) { return a / b; };
        default:
            throw new Error('未知操作');
    }
}

const add = createMathOperation('add');
const multiply = createMathOperation('multiply');

console.log(add(5, 3)); // 8
console.log(multiply(4, 6)); // 24

// 创建带特定配置的函数
function createGreeter(greeting, punctuation) {
    return function(name) {
        return `${greeting}, ${name}${punctuation}`;
    };
}

const formalGreet = createGreeter('您好', '！');
const casualGreet = createGreeter('嗨', '~');

console.log(formalGreet('张三')); // 您好，张三！
console.log(casualGreet('李四')); // 嗨，李四~
```

### 3. 状态管理

```javascript
function createStateManager(initialState = {}) {
    let state = { ...initialState };
    const listeners = [];

    function notifyListeners() {
        listeners.forEach(listener => listener(state));
    }

    return {
        getState: function() {
            return { ...state }; // 返回副本，避免外部修改
        },

        setState: function(newState) {
            state = { ...state, ...newState };
            notifyListeners();
        },

        subscribe: function(listener) {
            listeners.push(listener);
            return function() {
                const index = listeners.indexOf(listener);
                if (index > -1) {
                    listeners.splice(index, 1);
                }
            };
        }
    };
}

const store = createStateManager({ count: 0, user: null });

// 订阅状态变化
const unsubscribe = store.subscribe((newState) => {
    console.log('状态变化:', newState);
});

store.setState({ count: 1 }); // 状态变化: { count: 1, user: null }
store.setState({ count: 2, user: '张三' }); // 状态变化: { count: 2, user: '张三' }

unsubscribe();
```

### 4. 防抖和节流

```javascript
// 防抖函数
function debounce(func, delay) {
    let timeoutId;

    return function(...args) {
        clearTimeout(timeoutId);

        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// 节流函数
function throttle(func, delay) {
    let lastCall = 0;
    let timeoutId;

    return function(...args) {
        const now = Date.now();

        if (now - lastCall >= delay) {
            func.apply(this, args);
            lastCall = now;
        } else {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
                lastCall = now;
            }, delay - (now - lastCall));
        }
    };
}

// 使用示例
const debouncedSearch = debounce((query) => {
    console.log('搜索:', query);
}, 300);

const throttledScroll = throttle(() => {
    console.log('滚动事件处理');
}, 100);

// 模拟快速输入
debouncedSearch('j');
debouncedSearch('ja');
debouncedSearch('jav');
debouncedSearch('java');
debouncedSearch('javas');
debouncedSearch('javasc');
debouncedSearch('javascr');
debouncedSearch('javascri');
debouncedSearch('javascrip');
debouncedSearch('javascript');
// 只有最后一次会触发
```

## 高阶函数

### 什么是高阶函数

高阶函数是指接受函数作为参数或返回函数的函数。它们是函数式编程的核心概念。

```javascript
// 接受函数作为参数
function calculate(a, b, operation) {
    return operation(a, b);
}

const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

console.log(calculate(5, 3, add)); // 8
console.log(calculate(5, 3, multiply)); // 15

// 返回函数
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

### 内置高阶函数

#### 数组方法

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// map - 转换数组
const doubled = numbers.map(n => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

// filter - 过滤数组
const evenNumbers = numbers.filter(n => n % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8, 10]

// reduce - 累积计算
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 55

// find - 查找元素
const firstEven = numbers.find(n => n % 2 === 0);
console.log(firstEven); // 2

// some - 检查是否有元素满足条件
const hasEven = numbers.some(n => n % 2 === 0);
console.log(hasEven); // true

// every - 检查所有元素是否都满足条件
const allPositive = numbers.every(n => n > 0);
console.log(allPositive); // true

// forEach - 遍历数组
numbers.forEach((n, index) => {
    console.log(`索引 ${index}: ${n}`);
});

// sort - 排序数组
const sorted = [...numbers].sort((a, b) => b - a);
console.log(sorted); // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

#### 函数组合

```javascript
// 函数组合：将多个函数组合成一个新函数
const compose = (...functions) => (value) => {
    return functions.reduceRight((acc, fn) => fn(acc), value);
};

const pipe = (...functions) => (value) => {
    return functions.reduce((acc, fn) => fn(acc), value);
};

// 辅助函数
const add5 = x => x + 5;
const multiply3 = x => x * 3;
const subtract2 = x => x - 2;
const toString = x => x.toString();
const addPrefix = str => `结果: ${str}`;

// 使用 compose
const composed = compose(
    addPrefix,
    toString,
    subtract2,
    multiply3,
    add5
);

console.log(composed(10)); // 结果: 43

// 使用 pipe
const piped = pipe(
    add5,
    multiply3,
    subtract2,
    toString,
    addPrefix
);

console.log(piped(10)); // 结果: 43
```

### 自定义高阶函数

#### 记忆化（Memoization）

```javascript
function memoize(fn) {
    const cache = new Map();

    return function(...args) {
        const key = JSON.stringify(args);

        if (cache.has(key)) {
            console.log('缓存命中:', key);
            return cache.get(key);
        }

        console.log('计算结果:', key);
        const result = fn.apply(this, args);
        cache.set(key, result);

        return result;
    };
}

// 斐波那契数列（递归版本，性能较差）
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 记忆化版本
const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(10)); // 55
console.log(memoizedFibonacci(10)); // 55 (缓存命中)
console.log(memoizedFibonacci(15)); // 610
```

#### 函数柯里化

```javascript
// 柯里化：将多参数函数转换为单参数函数链
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...moreArgs) {
                return curried.apply(this, args.concat(moreArgs));
            };
        }
    };
}

// 使用柯里化
function add(a, b, c) {
    return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6

// 实际应用
const createValidator = curry((rules, data) => {
    return rules.every(rule => rule(data));
});

const isAdult = (person) => person.age >= 18;
const hasEmail = (person) => person.email;
const hasPhone = (person) => person.phone;

const validateAdult = createValidator([isAdult]);
const validateContact = createValidator([hasEmail, hasPhone]);
const validateComplete = createValidator([isAdult, hasEmail, hasPhone]);

const person = { name: '张三', age: 25, email: 'zhangsan@example.com', phone: '1234567890' };

console.log(validateAdult(person)); // true
console.log(validateContact(person)); // true
console.log(validateComplete(person)); // true
```

#### 部分应用

```javascript
// 部分应用：固定函数的部分参数
function partial(fn, ...presetArgs) {
    return function(...laterArgs) {
        return fn.apply(this, presetArgs.concat(laterArgs));
    };
}

// 使用部分应用
function calculateArea(length, width, height) {
    return length * width * height;
}

// 固定高度为 10
const calculateAreaWithHeight10 = partial(calculateArea, undefined, undefined, 10);

console.log(calculateAreaWithHeight10(5, 3)); // 150

// 固定长度和宽度
const calculateArea5x3 = partial(calculateArea, 5, 3);
console.log(calculateArea5x3(2)); // 30
console.log(calculateArea5x3(4)); // 60
```

## 函数式编程模式

### 1. 函数式数据结构

```javascript
// 不可变列表
class ImmutableList {
    constructor(elements = []) {
        this.elements = [...elements];
    }

    push(element) {
        return new ImmutableList([...this.elements, element]);
    }

    pop() {
        if (this.elements.length === 0) {
            return new ImmutableList();
        }
        return new ImmutableList(this.elements.slice(0, -1));
    }

    map(fn) {
        return new ImmutableList(this.elements.map(fn));
    }

    filter(fn) {
        return new ImmutableList(this.elements.filter(fn));
    }

    reduce(fn, initialValue) {
        return this.elements.reduce(fn, initialValue);
    }

    get length() {
        return this.elements.length;
    }
}

// 使用不可变列表
const list1 = new ImmutableList([1, 2, 3]);
const list2 = list1.push(4);
const list3 = list2.filter(n => n % 2 === 0);

console.log(list1.elements); // [1, 2, 3]
console.log(list2.elements); // [1, 2, 3, 4]
console.log(list3.elements); // [2, 4]
```

### 2. 函数式错误处理

```javascript
// Result 模式
class Result {
    static success(value) {
        return new Success(value);
    }

    static failure(error) {
        return new Failure(error);
    }
}

class Success extends Result {
    constructor(value) {
        super();
        this.value = value;
    }

    map(fn) {
        try {
            return Result.success(fn(this.value));
        } catch (error) {
            return Result.failure(error);
        }
    }

    chain(fn) {
        return fn(this.value);
    }

    getOrElse() {
        return this.value;
    }
}

class Failure extends Result {
    constructor(error) {
        super();
        this.error = error;
    }

    map() {
        return this;
    }

    chain() {
        return this;
    }

    getOrElse(defaultValue) {
        return defaultValue;
    }
}

// 使用 Result 模式
function divide(a, b) {
    if (b === 0) {
        return Result.failure(new Error('除数不能为零'));
    }
    return Result.success(a / b);
}

function square(x) {
    return Result.success(x * x);
}

const result = divide(10, 2)
    .chain(square)
    .chain(square);

console.log(result.getOrElse(0)); // 25

const errorResult = divide(10, 0)
    .chain(square)
    .chain(square);

console.log(errorResult.getOrElse(0)); // 0
```

### 3. 函数式状态管理

```javascript
// 函数式状态机
function createStateMachine(initialState, transitions) {
    return function(input) {
        return function(currentState = initialState) {
            const transition = transitions[currentState] && transitions[currentState][input];

            if (transition) {
                const newState = transition.nextState;
                const action = transition.action;

                if (action) {
                    action(currentState, input);
                }

                return newState;
            }

            return currentState;
        };
    };
}

// 简单的计数器状态机
const counterMachine = createStateMachine('stopped', {
    stopped: {
        start: { nextState: 'running', action: () => console.log('开始计数') },
        reset: { nextState: 'stopped', action: () => console.log('重置计数器') }
    },
    running: {
        increment: { nextState: 'running', action: (state, input) => console.log(`计数: ${input}`) },
        stop: { nextState: 'stopped', action: () => console.log('停止计数') },
        reset: { nextState: 'stopped', action: () => console.log('重置计数器') }
    }
});

// 使用状态机
let state = 'stopped';
state = counterMachine('start')(state); // 开始计数
state = counterMachine('increment')(state); // 计数: undefined
state = counterMachine('stop')(state); // 停止计数
state = counterMachine('reset')(state); // 重置计数器
```

## 性能优化

### 闭包性能考虑

```javascript
// 避免在循环中创建闭包
function createHandlersBad(items) {
    const handlers = [];

    for (let i = 0; i < items.length; i++) {
        // 每次循环都创建一个新的闭包
        handlers.push(function() {
            console.log(items[i]); // 问题：所有函数都引用同一个 i
        });
    }

    return handlers;
}

// 正确方式
function createHandlersGood(items) {
    const handlers = [];

    for (let i = 0; i < items.length; i++) {
        // 使用 IIFE 创建独立的作用域
        (function(index) {
            handlers.push(function() {
                console.log(items[index]);
            });
        })(i);
    }

    return handlers;
}

// 更好的方式：使用 let
function createHandlersBest(items) {
    const handlers = [];

    for (let i = 0; i < items.length; i++) {
        handlers.push(function() {
            console.log(items[i]);
        });
    }

    return handlers;
}
```

### 内存泄漏防护

```javascript
// 避免循环引用
function createCircularReference() {
    const obj1 = { data: 'data1' };
    const obj2 = { data: 'data2' };

    obj1.next = obj2;
    obj2.prev = obj1;

    // 手动清理引用
    return function cleanup() {
        obj1.next = null;
        obj2.prev = null;
    };
}

const cleanup = createCircularReference();
// 使用完毕后调用
cleanup();

// 使用 WeakMap 避免强引用
const cache = new WeakMap();

function memoizeWeak(fn) {
    return function(obj) {
        if (cache.has(obj)) {
            return cache.get(obj);
        }

        const result = fn(obj);
        cache.set(obj, result);

        return result;
    };
}
```

## 调试闭包和高阶函数

### 闭包调试技巧

```javascript
// 添加调试信息
function createDebugger(fn, name) {
    return function(...args) {
        console.log(`[${name}] 调用参数:`, args);
        const result = fn.apply(this, args);
        console.log(`[${name}] 返回结果:`, result);
        return result;
    };
}

// 闭包状态监控
function createMonitoredClosure() {
    let count = 0;
    const callHistory = [];

    return {
        increment: function() {
            count++;
            callHistory.push({ action: 'increment', value: count, time: Date.now() });
            return count;
        },
        decrement: function() {
            count--;
            callHistory.push({ action: 'decrement', value: count, time: Date.now() });
            return count;
        },
        getHistory: function() {
            return [...callHistory];
        },
        getCount: function() {
            return count;
        }
    };
}

const monitoredCounter = createMonitoredClosure();
monitoredCounter.increment();
monitoredCounter.increment();
monitoredCounter.decrement();
console.log(monitoredCounter.getHistory());
```

## 总结

闭包和高阶函数是 JavaScript 函数式编程的核心概念，它们提供了强大的抽象能力和代码组织方式。本文深入探讨了：

- 闭包的机制和生命周期
- 闭包在实际开发中的应用（私有变量、函数工厂、状态管理）
- 高阶函数的概念和使用
- 函数式编程模式（记忆化、柯里化、部分应用）
- 函数式数据结构和错误处理
- 性能优化和内存管理
- 调试技巧

掌握这些概念将帮助你编写更加优雅、可维护和高效的 JavaScript 代码。通过合理使用闭包和高阶函数，你可以创建出功能强大且易于理解的函数式程序。

这个系列的五篇博客涵盖了 JavaScript 的核心概念，从基础语法到高级特性，为你的项目开发提供了坚实的理论基础。